# -*- coding: utf-8 -*-
# ======================================================================
# üöÄ SIMONWEB ‚Äì FIREFOX ‚Äì MULTI-TABS ‚Äì LOCAL (Python + Playwright)
# ======================================================================

import asyncio
import json
import inspect
import unicodedata
from typing import Optional, List

from playwright.async_api import (
    async_playwright,
    Browser,
    BrowserContext,
    Page,
    TimeoutError as PlaywrightTimeoutError,
)

# =========================
# CONFIG
# =========================
CONFIG = {
    "login_url": "https://intranet.bolnet.com.co/SimonWeb/securityServlet",
    "filtros_url": "https://intranet.bolnet.com.co/SimonWeb/pages/emision/poliza/paginaFiltros.jsf?modoPantalla=CREAR_COTIZA",

    # Credenciales y compa√±√≠a
    "usuario": "52090075",
    "clave": "Ale02falcao",
    "compania_id": "3",

    # Datos para frmDatosFijos / frmTerceroNatural
    "fecha_inicio_vigencia": "28/11/2025",
    "numero_documento_tercero": "805012610",

    # Datos del tercero (para alta nueva)
    "sexo": "F",  # M o F
    "estado_civil": "1",  # 1-Soltero, 2-Casado...

    # Contacto
    "celular_tercero": "3138926061",
    "telefono_residencia_tercero": "1234567",
    "direccion_residencia_tercero": "Calle 123 #45-67",
    "email_tercero": "correo@ejemplo.com",

    # Datos adicionales frmDatosFijos
    "tipo_envio": "PE",
    "clave_lider": "31194",
    "age_pactado": "6",

    # Localidad del formulario
    "localidad": "BOGOTA",

    # Datos en frmRiesgosPoliza

    "auto_suma_asegurada": "66,989,999",
    # Uso y cobertura
    "auto_uso_value": "31 - PARTICULAR FAMILIAR",
    "auto_cobertura_value": "43 - OPCIONES - Riesgos Patrimoniales , Da√±o Total , Da√±os Parciales , Terremoto , Hurto Parcial Y Total",
    "auto_color": "GRIS PLATINO METALICO",
    # ...
    "dv_dano_total_value": "118",
    "dv_dano_total_text": "118 - 0 % 0 SMMLV",

    # Ventana / tiempos

    "viewport": None,

    # Argumento clave para maximizar la ventana en Chromium/Chrome
    "browser_args": ["--start-maximized"],

    "timeout_general": 30000,
    "headless": False,
    "slow_mo": 0,
    "keep_open": True,

    # Selector del <select> programa en filtros
    "segundo_select_css": "#frmPaginaFiltros\\:programa",

    "Num_Documento": "52090075",
    "Ecom_Password": "Ale02falcao",
    "tipo_documento_tomador": "NT",
    "Numero_documento_tomador": "805012610",
    "primer_nombre": "",
    "primer_apellido": "",
    "segundo_nombre": "",
    "segundo_apellido": " ",
    "fecha_nacimiento": "01/10/1993",
    "nacionalidad": "COLOMBIA",
    "ciudad_residencia": "TULUA",
    "direccion_residencia": "CARRERA 98 24 36",
    "telefono_residencia": "",
    "email": "adriana.guzman.acosta@gmail.com",
    "OBSERVACI√ìN": "CONVENIO PORSCHE",
    "Clave_lider": "31194",
    "Comision": "6",
    "placa": "NDK818",
    "VALOR ASEGURADO": "82990000",
    "ASEGURADO DOCUMENTO": "1116263393",
    "NOMBRE CONDUCTOR": "QUESADA ORTIZ JAIME ANDRES",
    "TIPO_DOC_ASEGURADO": "CC",
    "SEXO": "M",
    "TIpo poliza": "ESTANDAR",
    "BENEFICIARIO ONEROSO": "900628110",
    "Tipo_doc_benfeciaro_oneroso": "NT",
    "FASECOLDA": "9201283",
    "Numero_motor": "DHSB14626",
    "Numero_chasis": "9BWAH5BZ9TT621624",
    "auto_modelo_value": "2026 - MODELO 2026"
}
# User-Agent realista (para Firefox)
REALISTIC_USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) "
    "Gecko/20100101 Firefox/128.0"
)

# Script de "stealth" b√°sico
STEALTH_INIT_SCRIPT = r"""
(() => {
  try {
    Object.defineProperty(navigator, 'webdriver', { get: () => false });
  } catch(e) {}

  try {
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters) =>
      parameters.name === 'notifications'
        ? Promise.resolve({ state: Notification.permission })
        : originalQuery(parameters);
  } catch(e) {}

  try {
    Object.defineProperty(window, 'chrome', { value: {} });
  } catch(e) {}

  try {
    const originalPlugins = navigator.plugins;
    if (!originalPlugins || originalPlugins.length === 0) {
      Object.defineProperty(navigator, 'plugins', { get: () => [1,2,3,4,5] });
    }
  } catch(e) {}
})();
"""


# =========================
# PRINT con l√≠nea y funci√≥n
# =========================
def pr(msg: str, tipo: str = "INFO"):
    f = inspect.currentframe().f_back
    print(f"[{tipo}] (L{f.f_lineno}, {f.f_code.co_name}) {msg}", flush=True)


def strip_accents(text: str) -> str:
    if not text:
        return text
    nfkd = unicodedata.normalize("NFD", text)
    return "".join(ch for ch in nfkd if unicodedata.category(ch) != "Mn")


async def safe_fill_and_tab(page: Page, selector: str, value: str, desc: str) -> bool:
    try:
        await page.wait_for_selector(selector, timeout=5000)
        await page.fill(selector, value)
        pr(f"{desc}: valor '{value}' escrito en {selector}")
        await page.press(selector, "Tab")
        pr(f"{desc}: Tab presionado en {selector}")
        return True
    except Exception as e:
        pr(f"{desc}: no se pudo llenar o hacer Tab en {selector} -> {e}", "WARN")
        return False


# =========================
# Utilidades
# =========================
async def wait(ms: int):
    await asyncio.sleep(ms / 1000)


async def wait_for_loader(p: Page, timeout: int = 8000) -> bool:
    pr("Esperando loader‚Ä¶")
    js = """
    () => {
      if (document.querySelector(".rf-st-start") || document.querySelector(".rf-st-rich")) return true;
      const ids = ["#loadingImage", "#ajaxStatusPanel", "#statusPanel", "#statusPanel_container"];
      return ids.some(sel => {
        const el = document.querySelector(sel);
        return el && el.offsetParent !== null;
      });
    }"""
    step = 200
    elapsed = 0
    while elapsed < timeout:
        try:
            active = await p.evaluate(js)
        except Exception:
            active = True
        if not active:
            return True
        await asyncio.sleep(step / 1000)
        elapsed += step
    pr("Loader no desapareci√≥.", "WARN")
    return False


async def safe_click(page: Page, selectors: List[str], desc: str) -> bool:
    for sel in selectors:
        try:
            await page.wait_for_selector(sel, timeout=4000)
            loc = page.locator(sel)
            await loc.scroll_into_view_if_needed()
            await loc.click()
            pr(f"Click en {desc} ({sel})")
            return True
        except Exception:
            continue
    pr(f"No se pudo hacer click en {desc}.", "WARN")
    return False


async def safe_fill(page: Page, selectors: List[str], value: str, desc: str) -> bool:
    for sel in selectors:
        try:
            await page.fill(sel, value, timeout=1500)
            pr(f"Campo {desc} rellenado en {sel}")
            return True
        except Exception:
            continue
    pr(f"No se encontr√≥ campo para {desc}.")
    return False


# =========================
# VERSION ROBUSTA LOGIN
# =========================
async def robust_fill(page: Page, selectors: List[str], value: str, desc: str) -> bool:
    for sel in selectors:
        try:
            if await page.is_visible(sel):
                await page.click(sel)
                await page.fill(sel, "")
                await page.type(sel, value, delay=100)

                await page.evaluate(f"""
                    var el = document.querySelector('{sel}');
                    if (!el) return;
                    el.dispatchEvent(new Event('input', {{bubbles: true}}));
                    el.dispatchEvent(new Event('change', {{bubbles: true}}));
                    if (el.blur) el.blur();
                """)
                pr(f"Campo {desc} llenado robustamente.")
                return True
        except Exception:
            continue

    pr(f"No se encontr√≥ campo para {desc}.", "WARN")
    return False


async def click_human(page: Page, selectors: List[str], desc: str) -> bool:
    for sel in selectors:
        try:
            if await page.is_visible(sel):
                loc = page.locator(sel)
                await loc.scroll_into_view_if_needed()
                await loc.hover()
                await asyncio.sleep(0.5)
                await loc.click(force=True)
                pr(f"Click exitoso en {desc} ({sel})")
                return True
        except Exception:
            continue
    pr(f"No se pudo hacer click en {desc}.", "WARN")
    return False


# ============ bloquear cierre de pesta√±as ============
INIT_SCRIPT_BLOCK_CLOSE_HARD = r"""
(() => {
  const noop = () => {};
  try {
    const targets = [window, self];
    try { if (window.top) targets.push(window.top); } catch(e){}
    try { if (window.parent) targets.push(window.parent); } catch(e){}
    try { if (window.opener) targets.push(window.opener); } catch(e){}
    for (const t of targets) { try { t.close = noop; } catch(e){} }
    const _open = window.open;
    window.open = function(url, name, specs) {
      const w = _open ? _open.call(window, url, name, specs) : null;
      try { if (w) { w.close = noop; } } catch(e){}
      return w;
    };
    window.addEventListener('beforeunload', (e) => { e.preventDefault(); e.returnValue=''; return ''; });
  } catch(e){}
})();
"""


def attach_reopen_on_close(context: BrowserContext, label: str, url_to_restore: Optional[str] = None):
    def _wrap(page: Page):
        async def _reopen():
            try:
                last_url = url_to_restore or page.url
            except Exception:
                last_url = url_to_restore
            print(f"[WARN] (reopen) '{label}' cerrada. Reabriendo {last_url or '(en blanco)'}‚Ä¶", flush=True)
            newp = await context.new_page()
            await newp.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
            if last_url:
                try:
                    await newp.goto(last_url, wait_until="load", timeout=15000)
                    print(f"[INFO] (reopen) '{label}' reabierta en {last_url}", flush=True)
                except Exception as e:
                    print(f"[ERROR] (reopen) Fall√≥ reabrir: {e}", flush=True)

        page.on("close", lambda: asyncio.ensure_future(_reopen()))

    return _wrap


async def open_url_resilient(context: BrowserContext, url: str, label: str, max_tries: int = 4) -> Page:
    for i in range(1, max_tries + 1):
        print(f"[INFO] (open_url_resilient) {label} intento {i}/{max_tries}", flush=True)
        p = await context.new_page()
        await p.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
        attach_reopen_on_close(context, label, url)(p)
        try:
            await p.goto(url, wait_until="load", timeout=15000)
            await asyncio.sleep(0.4)
            if p.is_closed():
                print("[WARN] (open_url_resilient) Pesta√±a se cerr√≥ tras cargar, reintentando‚Ä¶", flush=True)
                continue
            return p
        except Exception as e:
            print(f"[WARN] (open_url_resilient) goto fall√≥: {e}", flush=True)
            try:
                if not p.is_closed():
                    await p.close()
            except Exception:
                pass
            await asyncio.sleep(0.3)
    last = await context.new_page()
    await last.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
    attach_reopen_on_close(context, label, url)(last)
    return last


async def handle_acceso_denegado(context: BrowserContext, current_tab: Page, url: str) -> Page:
    try:
        html = await current_tab.content()
    except Exception:
        html = ""
    if ("Acceso Denegado" in html) or ("denegado" in html.lower()):
        print("[WARN] Acceso Denegado detectado.", flush=True)
        await asyncio.sleep(1.0)
        for p in context.pages:
            try:
                u = (p.url or "").lower()
            except Exception:
                u = ""
            if p is not current_tab and (u == "about:blank" or u.startswith("moz-extension://") or "deneg" in u):
                print("[INFO] Usando pesta√±a auto-abierta‚Ä¶", flush=True)
                await p.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
                attach_reopen_on_close(context, "auto", url)(p)
                await p.bring_to_front()
                try:
                    await p.goto(url, wait_until="load", timeout=15000)
                    await asyncio.sleep(0.3)
                    if not p.is_closed():
                        return p
                except Exception as e:
                    print(f"[WARN] Fall√≥ auto-abierta: {e}", flush=True)
        print("[INFO] Creando nueva pesta√±a para reintentar‚Ä¶", flush=True)
        return await open_url_resilient(context, url, "retry")
    return current_tab


# =========================
# Selects RichFaces/JSF
# =========================
async def select_richfaces_value(page: Page, css_select: str, value: str, wait_ajax_ms: int = 1200) -> bool:
    try:
        await page.wait_for_selector(css_select, state="visible", timeout=7000)
    except Exception:
        print(f"[WARN] No encontr√© el select {css_select}", flush=True)
        return False

    try:
        await page.select_option(css_select, value)
    except Exception:
        pass

    try:
        curr = await page.eval_on_selector(css_select, "el => el.value")
    except Exception:
        curr = None

    if curr != value:
        result = await page.evaluate(
            """(args) => {
                const { sel, val } = args;
                const s = document.querySelector(sel);
                if (!s) return null;
                const norm = (v) => (v || '').trim();
                const target = norm(val);
                const opts = [...s.options];

                let opt = opts.find(o => norm(o.value) === target);
                if (!opt) {
                    opt = opts.find(o => norm(o.value).startsWith(target));
                }
                if (!opt) return null;

                s.value = opt.value;
                s.dispatchEvent(new Event('change', { bubbles: true }));
                s.dispatchEvent(new Event('input',  { bubbles: true }));
                s.blur && s.blur();

                const selected = s.options[s.selectedIndex] || opt;
                return {
                    value: selected.value || '',
                    text: selected.text || ''
                };
            }""",
            {"sel": css_select, "val": value}
        )

        if result:
            curr = result["value"]
            print(
                f"[INFO] {css_select} (JS fallback) -> value='{result['value']}' text='{result['text']}'",
                flush=True
            )
        else:
            print(f"[WARN] JS fallback no encontr√≥ opci√≥n para value='{value}' en {css_select}", flush=True)
    else:
        print(f"[INFO] {css_select} -> set={curr} target={value}", flush=True)

    await asyncio.sleep(wait_ajax_ms / 1000)
    return curr is not None and curr != ""


async def select_any_with_value(page: Page, value: str, wait_ajax_ms: int = 1200) -> bool:
    sel = await page.evaluate(
        """(args) => {
            const { val } = args;
            const sels = [...document.querySelectorAll('select')].filter(s => {
              const cs = getComputedStyle(s);
              return s.offsetParent !== null && cs.display !== 'none' && cs.visibility !== 'hidden';
            });
            for (const s of sels) {
              if ([...s.options].some(o => o.value === val)) {
                if (s.id) return `#${CSS.escape(s.id)}`;
                if (s.name) return `select[name="${s.name}"]`;
                const idx = sels.indexOf(s);
                return `select:nth-of-type(${idx+1})`;
              }
            }
            return null;
        }""",
        {"val": value}
    )
    if not sel:
        print(f"[WARN] No hall√© ning√∫n <select> con option[value='{value}']", flush=True)
        return False
    return await select_richfaces_value(page, sel, value, wait_ajax_ms)


async def select_richfaces_by_human_keys(page, selector, target_text, desc="", wait_ajax_ms=1200):
    """
    Selecciona una opci√≥n RichFaces usando teclas humanas:
    Click -> ArrowDown/Up -> Enter -> Tab -> esperar loader -> validar.
    """
    try:
        await page.wait_for_selector(selector, state="visible", timeout=15000)
    except Exception:
        print(f"[ERROR] {desc} no visible: {selector}", flush=True)
        return False

    # 1. Click en el select
    try:
        await page.click(selector)
        await asyncio.sleep(0.3)
    except Exception as e:
        print(f"[ERROR] Click en {desc} fall√≥: {e}", flush=True)
        return False

    # 2. Leer opciones desde el DOM
    try:
        options = await page.eval_on_selector_all(
            selector + " option",
            "els => els.map(x => x.textContent.trim())"
        )
    except:
        print(f"[ERROR] No se pudieron leer opciones de {desc}", flush=True)
        return False

    if not options:
        print(f"[ERROR] {desc} NO tiene opciones.", flush=True)
        return False

    # Encontrar √≠ndice del texto buscado
    try:
        idx = options.index(target_text)
    except ValueError:
        print(f"[ERROR] '{target_text}' NO est√° en las opciones de {desc}.", flush=True)
        return False

    # 3. Recorrer con ArrowDown hasta la opci√≥n correcta
    for _ in range(idx):
        await page.keyboard.press("ArrowDown")
        await asyncio.sleep(0.1)

    # 4. Confirmar opci√≥n
    await page.keyboard.press("Enter")
    await asyncio.sleep(0.2)

    # 5. Disparar onchange / blur
    await page.keyboard.press("Tab")
    await asyncio.sleep(0.2)

    # 6. Esperar AJAX loader
    try:
        await wait_for_loader(page, timeout=15000)
    except:
        print(f"[WARN] Loader no detectado para {desc}", flush=True)

    # 7. Validar selecci√≥n real
    try:
        val, txt = await page.eval_on_selector(
            selector,
            """el => {
                const v = el.value;
                const t = el.options[el.selectedIndex]?.textContent.trim() || "";
                return [v, t];
            }"""
        )
    except:
        print(f"[ERROR] No se pudo leer estado final de {desc}", flush=True)
        return False

    print(f"[DEBUG] {desc} seleccionado -> value='{val}', text='{txt}'", flush=True)

    return txt == target_text or txt.startswith(target_text)


async def select_option_by_text(
        page: Page,
        css_select: str,
        text: str,
        desc: str,
        wait_ajax_ms: int = 1200,
        max_wait_ms: int = 20000,
) -> bool:
    """
    Selecciona <option> por TEXTO visible (innerText).
    Espera a que carguen opciones (AJAX) ‚Üí m√≠nimo > 1 opci√≥n.
    Blindado: cualquier fallo en page.evaluate se captura y NO rompe el flujo.
    """
    try:
        await page.wait_for_selector(css_select, state="visible", timeout=7000)
    except Exception:
        pr(f"[{desc}] No encontr√© el select {css_select}", "WARN")
        return False

    elapsed = 0
    step = 500
    first_dump = True

    while elapsed <= max_wait_ms:
        try:
            result = await page.evaluate(
                """
                (args) => {
                    const { sel, text } = args;
                    const s = document.querySelector(sel);
                    if (!s) return { found: false, options: [] };

                    const norm = v => (v || '')
                        .replace(/\\u00a0/g, ' ')
                        .replace(/\\s+/g, ' ')
                        .trim()
                        .toUpperCase();

                    const target = norm(text);
                    const opts = Array.from(s.options).map(o => ({
                        text: o.text,
                        value: o.value
                    }));

                    // Si solo est√° "--Seleccione--", a√∫n no cargan las opciones reales
                    if (opts.length <= 1) {
                        return { found: false, options: opts };
                    }

                    let opt = opts.find(o => norm(o.text) === target);
                    if (!opt) opt = opts.find(o => norm(o.text).includes(target));
                    if (!opt) return { found: false, options: opts };

                    const realOpt = Array.from(s.options).find(
                        o => o.text === opt.text && o.value === opt.value
                    );
                    if (!realOpt) return { found: false, options: opts };

                    s.value = realOpt.value;
                    s.dispatchEvent(new Event('change', { bubbles: true }));
                    s.dispatchEvent(new Event('input',  { bubbles: true }));
                    if (typeof s.blur === 'function') s.blur();

                    return {
                        found: true,
                        selected: {
                            value: realOpt.value || '',
                            text: realOpt.text || ''
                        },
                        options: opts
                    };
                }
                """,
                {"sel": css_select, "text": text}
            )
        except Exception as e:
            # Captura cualquier cosa rara dentro del evaluate
            pr(f"[{desc}] Error en page.evaluate(select_option_by_text): {e}", "ERROR")
            return False

        if result and result.get("found"):
            sel_info = result.get("selected", {})
            pr(
                f"[{desc}] seleccionado -> value='{sel_info.get('value', '')}' "
                f"text='{sel_info.get('text', '')}' en {css_select}"
            )
            await asyncio.sleep(wait_ajax_ms / 1000)
            return True

        if first_dump and result:
            first_dump = False
            opts = result.get("options", [])
            try:
                opts_str = ", ".join(["'{}'".format(o["text"]) for o in opts])
            except Exception:
                opts_str = "<error leyendo opciones>"
            pr(f"[{desc}] opciones visibles en {css_select}: {opts_str}")

        await asyncio.sleep(step / 1000)
        elapsed += step

    pr(f"[{desc}] No se encontr√≥ opci√≥n con texto '{text}' en {css_select}", "WARN")
    return False


# =========================
# MAIN
# =========================
async def main():
    browser: Browser = None
    context: BrowserContext = None
    main_page: Page = None
    popup: Optional[Page] = None
    filtros_tab: Optional[Page] = None

    success = False
    url_final = None
    err = None

    try:
        pr("Lanzando Firefox local‚Ä¶")
        async with async_playwright() as pw:
            browser = await pw.firefox.launch(
                headless=CONFIG["headless"],
                slow_mo=CONFIG["slow_mo"],
            )
            context = await browser.new_context(
                user_agent=REALISTIC_USER_AGENT,
                viewport=CONFIG["viewport"],
            )
            await context.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
            await context.add_init_script(STEALTH_INIT_SCRIPT)

            context.set_default_timeout(9000)
            context.set_default_navigation_timeout(15000)

            # Ventana principal
            main_page = await context.new_page()
            attach_reopen_on_close(context, "main")(main_page)

            # =========================
            # LOGIN ROBUSTO
            # =========================
            pr("Cargando p√°gina de Login...")
            await main_page.goto(
                CONFIG["login_url"],
                wait_until="domcontentloaded",
                timeout=CONFIG["timeout_general"],
            )
            await main_page.wait_for_load_state("networkidle")

            await robust_fill(
                main_page,
                ["#Num_Documento", "input[name='Ecom_User_ID']"],
                CONFIG["usuario"],
                "Usuario",
            )
            await asyncio.sleep(0.5)

            await robust_fill(
                main_page,
                ["input[type='password']", "input[name='Ecom_Password']"],
                CONFIG["clave"],
                "Contrase√±a",
            )

            pr("Esperando validaci√≥n interna...")
            await asyncio.sleep(1.5)

            pr("Intentando ingresar...")
            initial_url = main_page.url
            popup = None

            popup_future = context.wait_for_event("page", timeout=15000)

            btn_selectors = [
                "input[type='submit'][value='INGRESA']",
                "input[value='INGRESA']",
                "form#form1 input[type='submit']",
            ]
            clicked = await click_human(main_page, btn_selectors, "Bot√≥n INGRESA")

            if clicked:
                try:
                    popup = await popup_future
                    await popup.wait_for_load_state()
                    pr(f"¬°√âXITO! Popup detectado: {popup.url}")
                    await popup.add_init_script(INIT_SCRIPT_BLOCK_CLOSE_HARD)
                    attach_reopen_on_close(context, "popup")(popup)
                except PlaywrightTimeoutError:
                    if main_page.url != initial_url:
                        pr(f"¬°√âXITO! Redirecci√≥n detectada: {main_page.url}")
                        popup = main_page
                    else:
                        pr("ALERTA: El click no funcion√≥. Activando JS Submit...", "WARN")
                        await main_page.evaluate("""
                            const form = document.querySelector('form') || document.forms[0];
                            if (form) form.submit();
                        """)
                        try:
                            await main_page.wait_for_load_state("networkidle", timeout=10000)
                        except Exception:
                            pass
                        if main_page.url != initial_url:
                            pr(f"JS Submit funcion√≥. Nueva URL: {main_page.url}")
                            popup = main_page
            else:
                pr("No se pudo hacer click en INGRESA. Intentando JS submit directo‚Ä¶", "WARN")
                await main_page.evaluate("""
                    const form = document.querySelector('form') || document.forms[0];
                    if (form) form.submit();
                """)
                try:
                    await main_page.wait_for_load_state("networkidle", timeout=10000)
                except Exception:
                    pass
                if main_page.url != initial_url:
                    pr(f"JS Submit funcion√≥. Nueva URL: {main_page.url}")
                    popup = main_page

            if popup is None:
                popup = main_page

            # =========================
            # Popup / selecci√≥n de compa√±√≠a
            # =========================
            if popup:
                await safe_fill(popup, ["input[name='Ecom_User_ID']"], CONFIG["usuario"], "Usuario (popup)")
                await safe_fill(popup, ["input[name='Ecom_Password']"], CONFIG["clave"], "Contrase√±a (popup)")
                await safe_click(popup, ["#j_idt138", "button:has-text('OK')", "input[value='OK']"], "OK")
                await wait(600)
                await wait_for_loader(popup, timeout=7000)

                try:
                    await popup.wait_for_selector("#companyForm\\:companyList", timeout=7000)
                    await popup.select_option("#companyForm\\:companyList", CONFIG["compania_id"])
                    await wait_for_loader(popup, timeout=7007)
                except Exception:
                    pr("No hay selector de compa√±√≠a (o ya est√° seteado).")

                await safe_click(
                    popup,
                    ["#companyForm\\:j_idt129", "button:has-text('Continuar')", "input[value='Continuar']"],
                    "Continuar",
                )
                await wait_for_loader(popup, timeout=7000)

            # =========================
            # Abrir filtros
            # =========================
            print("[INFO] Abriendo paginaFiltros.jsf en pesta√±a nueva‚Ä¶", flush=True)
            filtros_tab = await open_url_resilient(context, CONFIG["filtros_url"], "filtros", max_tries=4)
            filtros_tab = await handle_acceso_denegado(context, filtros_tab, CONFIG["filtros_url"])

            if filtros_tab.is_closed():
                print("[ERROR] La pesta√±a de filtros est√° cerrada.", flush=True)
            else:
                await filtros_tab.bring_to_front()
                print("[INFO] Filtros abiertos / pesta√±a viva.", flush=True)

                # 1) producto 250
                PRODUCTO_SEL = "#frmPaginaFiltros\\:producto"
                print("[INFO] Seleccionando 250 en frmPaginaFiltros:producto‚Ä¶", flush=True)
                ok_250 = await select_richfaces_value(filtros_tab, PRODUCTO_SEL, "250", wait_ajax_ms=1400)
                if not ok_250:
                    print("[WARN] No se pudo seleccionar 250 en frmPaginaFiltros:producto", flush=True)
                else:
                    print("[OK] Seleccionado 250 en frmPaginaFiltros:producto", flush=True)

                # 2) programa 251
                print("[INFO] Intentando seleccionar 251 (programa)‚Ä¶", flush=True)
                ok_251 = False
                try:
                    ok_251 = await select_richfaces_value(
                        filtros_tab, CONFIG["segundo_select_css"], "251", wait_ajax_ms=1200
                    )
                except Exception:
                    ok_251 = False

                if not ok_251:
                    print("[INFO] Reintentando 251 por b√∫squeda din√°mica‚Ä¶", flush=True)
                    ok_251 = await select_any_with_value(filtros_tab, "251", wait_ajax_ms=1200)

                if ok_251:
                    print("[OK] Seleccionado 251.", flush=True)
                else:
                    print("[WARN] No se pudo seleccionar 251.", flush=True)

                # =========================
                # Click en bot√≥n "Continuar ¬ª" de Filtros (frmPaginaFiltros:j_idt323)
                # =========================
                FECHA_SEL = "xpath=//*[@id='frmDatosFijos:fechaInicioVigenciaInputDate']"

                MAX_REINTENTOS_FILTROS = 3
                filtros_ok = False

                # Lista unificada de posibles selectores para el bot√≥n "Continuar ¬ª"
                POSIBLES_SELECTORES = [
                    # 1. Por el TEXTO exacto del bot√≥n (el m√°s seguro si el value no cambia)
                    "input[value='Continuar ¬ª']",

                    # 2. Por TEXTO parcial (si alguna vez cambian las comillas angulares o el spacing)
                    "input[value*='Continuar']",

                    # 3. Por jerarqu√≠a CSS: input submit cuyo ID EMPIEZA por 'frmPaginaFiltros:'
                    "input[id^='frmPaginaFiltros:'][type='submit']",

                    # 4. Por atributos espec√≠ficos (si el tabindex 24 se mantiene estable)
                    "input[type='submit'][tabindex='24']",

                    # 5. Por ID directo conocido (el cl√°sico):
                    "#frmPaginaFiltros\\:j_idt323",

                    # 6. XPath gen√©rico con value
                    "xpath=//input[@type='submit' and contains(@value, 'Continuar')]",

                    # 7. XPath directo por id
                    "xpath=//*[@id='frmPaginaFiltros:j_idt323']",
                ]

                for intento in range(1, MAX_REINTENTOS_FILTROS + 1):
                    print(f"[INFO] Intento #{intento} click en frmPaginaFiltros:j_idt323‚Ä¶", flush=True)

                    # 1) Intento normal usando safe_click con TODOS los posibles selectores
                    click_ok = await safe_click(
                        filtros_tab,
                        POSIBLES_SELECTORES,
                        "Bot√≥n Continuar filtros (frmPaginaFiltros:j_idt323)",
                    )

                    # 2) Fallback "humano" directo: probamos a clickear manualmente cada selector
                    if not click_ok:
                        for sel in POSIBLES_SELECTORES:
                            try:
                                loc = filtros_tab.locator(sel)
                                if not await loc.is_visible():
                                    continue
                                await loc.scroll_into_view_if_needed()
                                await loc.hover()
                                await asyncio.sleep(0.3)
                                await loc.click(force=True)
                                click_ok = True
                                print(f"[OK] Click humano forzado en bot√≥n Continuar usando selector: {sel}",
                                      flush=True)
                                break
                            except Exception as e:
                                print(f"[WARN] Click humano con selector {sel} fall√≥: {e}", flush=True)

                    # 3) Fallback JS nuclear por id fijo
                    if not click_ok:
                        try:
                            js_ok = await filtros_tab.evaluate(
                                """
                                () => {
                                    const btn =
                                        document.getElementById('frmPaginaFiltros:j_idt323') ||
                                        [...document.querySelectorAll("input[type='submit']")]
                                            .find(b => (b.value || '').includes('Continuar'));
                                    if (!btn) return false;

                                    const ev = new MouseEvent('click', {
                                        bubbles: true,
                                        cancelable: true,
                                        view: window
                                    });
                                    btn.dispatchEvent(ev);

                                    if (typeof btn.click === 'function') {
                                        btn.click();
                                    }
                                    return true;
                                }
                                """
                            )
                            if js_ok:
                                click_ok = True
                                print("[OK] Click v√≠a JS en bot√≥n Continuar (j_idt323).", flush=True)
                            else:
                                print("[WARN] JS no encontr√≥ bot√≥n Continuar (j_idt323).", flush=True)
                        except Exception as e:
                            print(f"[ERROR] Fallback JS en frmPaginaFiltros:j_idt323 fall√≥: {e}", flush=True)

                    # 4) Siempre intentamos esperar loader si creemos que hubo click
                    if click_ok:
                        try:
                            await wait_for_loader(filtros_tab, timeout=10000)
                        except Exception:
                            print("[WARN] Loader no se detect√≥ (o no desapareci√≥) despu√©s del click en filtros.",
                                  flush=True)
                    else:
                        print("[WARN] Ning√∫n m√©todo logr√≥ hacer click en frmPaginaFiltros:j_idt323 en este intento.",
                              flush=True)

                    # 5) Validar que ya carg√≥ la pantalla de frmDatosFijos (FECHA_SEL)
                    try:
                        await filtros_tab.wait_for_selector(
                            FECHA_SEL,
                            state="visible",
                            timeout=8000,
                        )
                        print(
                            "[OK] Campo Fecha Inicio Vigencia visible despu√©s del click en filtros (j_idt323).",
                            flush=True,
                        )
                        filtros_ok = True
                        break
                    except Exception as e:
                        print(
                            f"[WARN] No se encontr√≥ FECHA_SEL tras el intento #{intento} "
                            f"(quiz√° no naveg√≥ bien a√∫n) -> {e}",
                            flush=True,
                        )
                        if intento < MAX_REINTENTOS_FILTROS:
                            print("[INFO] Reintentando click en bot√≥n filtros j_idt323‚Ä¶", flush=True)
                            await asyncio.sleep(1)
                        else:
                            print(
                                "[ERROR] Tras varios intentos, no se pudo llegar a frmDatosFijos "
                                "(Fecha Inicio Vigencia no apareci√≥).",
                                flush=True,
                            )

                if not filtros_ok:
                    print("[ERROR] Abortando flujo porque no se lleg√≥ a frmDatosFijos despu√©s de j_idt323.", flush=True)
                    # raise Exception("No se pudo abrir frmDatosFijos despu√©s de frmPaginaFiltros:j_idt323")

                # =========================
                # Fecha + doc (solo si filtros_ok)
                # =========================
                if filtros_ok:
                    await safe_fill_and_tab(
                        filtros_tab,
                        FECHA_SEL,
                        CONFIG["fecha_inicio_vigencia"],
                        "Fecha Inicio Vigencia",
                    )

                # ============================================================
                # SELECT: TIPO DE DOCUMENTO (frmDatosFijos:componenteTercero:tipoDocumento)
                # Seleccionar value="CC"
                # ============================================================

                TDOC_SEL = "select#frmDatosFijos\\:componenteTercero\\:tipoDocumento"
                TDOC_VALUE = CONFIG["tipo_documento_tomador"]  # SOLO VALUE

                pr(f"Intentando fijar TipoDocumento a value='{TDOC_VALUE}'", "INFO")

                # Esperar que exista y sea visible
                try:
                    await filtros_tab.wait_for_selector(TDOC_SEL, state="visible", timeout=15000)
                    pr("Select TipoDocumento visible.", "INFO")
                except Exception as e:
                    pr(f"[ERROR] TipoDocumento no visible en DOM: {e}", "ERROR")

                # ------------------------------
                # FUNCI√ìN: un solo intento
                # ------------------------------
                async def intentar_fijar_tdoc() -> bool:
                    try:
                        await filtros_tab.select_option(TDOC_SEL, TDOC_VALUE)
                        pr("[OK] TipoDocumento fijado v√≠a select_option(value).", "OK")
                        return True
                    except Exception as e:
                        pr(f"[WARN] select_option fall√≥: {e}", "WARN")
                        return False

                # ------------------------------
                # REINTENTOS + VERIFICACI√ìN REAL
                # ------------------------------
                max_intentos = 3
                ok_final = False

                for intento in range(1, max_intentos + 1):
                    pr(f"Intento TipoDocumento #{intento}", "INFO")

                    ok_try = await intentar_fijar_tdoc()

                    # Esperar loader RichFaces
                    try:
                        await wait_for_loader(filtros_tab, timeout=12000)
                    except:
                        pr("[WARN] Loader no detectado despu√©s de TipoDocumento.", "WARN")

                    await asyncio.sleep(1)

                    # Validar valor REAL seleccionado en DOM
                    try:
                        curr_value = await filtros_tab.eval_on_selector(
                            TDOC_SEL,
                            "el => el ? el.value : null"
                        )
                    except Exception as e:
                        curr_value = None
                        pr(f"[ERROR] No se pudo leer TipoDocumento: {e}", "ERROR")

                    pr(f"[DEBUG] TipoDocumento actual value='{curr_value}'")

                    if ok_try and curr_value == TDOC_VALUE:
                        pr("[OK] TipoDocumento qued√≥ correctamente en 'CC'.", "OK")
                        ok_final = True
                        break
                    else:
                        pr("[WARN] TipoDocumento NO qued√≥ en 'CC', reintentando‚Ä¶", "WARN")
                        await asyncio.sleep(1)

                if not ok_final:
                    pr("[ERROR] TipoDocumento NO se pudo fijar en 'CC' tras varios intentos.", "ERROR")

                NUM_DOC_SEL = "xpath=//*[@id='frmDatosFijos:componenteTercero:numeroDocumento']"
                await safe_fill_and_tab(
                    filtros_tab,
                    NUM_DOC_SEL,
                    CONFIG["Numero_documento_tomador"],
                    "Numero_documento_tomador",
                )

                # mensajeModificacion
                msg_sel = "xpath=//*[@id='frmTerceroNatural:mensajeModificacion']"
                msg_modif = False
                msg_info_actualizada = False

                try:
                    await filtros_tab.wait_for_selector(msg_sel, timeout=8000)
                    el = filtros_tab.locator(msg_sel)
                    msg_text = (await el.inner_text()).strip()
                    print(f"[INFO] mensajeModificacion encontrado: '{msg_text}'", flush=True)
                    lower_msg = msg_text.lower()
                    if "informaci√≥n actualizada" in lower_msg or "informacion actualizada" in lower_msg:
                        msg_modif = True
                        msg_info_actualizada = True
                    elif any(w in lower_msg for w in ["modific", "actualiz", "datos", "tercero"]):
                        msg_modif = True
                except Exception:
                    print("[INFO] No apareci√≥ mensajeModificacion ‚Üí TERCERO NUEVO.", flush=True)

                # =========================
                # Tercero nuevo / existente
                # =========================
                if not msg_modif:
                    # NUEVO
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:primerNombre']"],
                        CONFIG["primer_nombre"],
                        "Primer Nombre",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:segundoNombre']"],
                        CONFIG["segundo_nombre"],
                        "Segundo Nombre",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:primerApellido']"],
                        CONFIG["primer_apellido"],
                        "Primer Apellido",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:segundoApellido']"],
                        CONFIG["segundo_apellido"],
                        "Segundo Apellido",
                    )

                    await safe_fill_and_tab(
                        filtros_tab,
                        "xpath=//*[@id='frmTerceroNatural:fechaNacimientoInputDate']",
                        CONFIG["fecha_nacimiento"],
                        "Fecha nacimiento",
                    )

                    sexo_val = CONFIG.get("sexo", "M").upper()
                    sexo_id = (
                        "xpath=//*[@id='frmTerceroNatural:sexo:0']"
                        if sexo_val == "M"
                        else "xpath=//*[@id='frmTerceroNatural:sexo:1']"
                    )
                    await safe_click(filtros_tab, [sexo_id], f"Sexo {sexo_val}")

                    ESTADO_SEL = "xpath=//*[@id='frmTerceroNatural:estadoCivil']"
                    try:
                        await filtros_tab.select_option(ESTADO_SEL, CONFIG["estado_civil"])
                    except Exception as e:
                        print(f"[WARN] No se pudo seleccionar estado civil ‚Üí {e}", flush=True)

                    ciudad_plain = strip_accents(CONFIG["ciudad_residencia"]).upper()
                    CIUDAD_SEL = "xpath=//*[@id='frmTerceroNatural:ciudadResidenciaInput']"
                    try:
                        await filtros_tab.wait_for_selector(CIUDAD_SEL, timeout=8000)
                        ciudad_input = filtros_tab.locator(CIUDAD_SEL)
                        await ciudad_input.click()
                        await ciudad_input.fill("")
                        await ciudad_input.type(ciudad_plain, delay=150)
                        await filtros_tab.press(CIUDAD_SEL, "Enter")
                    except Exception as e:
                        print(f"[WARN] No se pudo escribir ciudad residencia (nuevo) ‚Üí {e}", flush=True)

                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:celular']"],
                        CONFIG["celular_tercero"],
                        "Celular tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:telefonoResidencia']"],
                        CONFIG["telefono_residencia_tercero"],
                        "Tel√©fono residencia tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:direccionResidencia']"],
                        CONFIG["direccion_residencia_tercero"],
                        "Direcci√≥n residencia tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:email']"],
                        CONFIG["email_tercero"],
                        "Email tercero",
                    )

                    do_guardar = True
                    do_cancelar = False

                else:
                    # EXISTENTE
                    ciudad_plain = strip_accents(CONFIG["ciudad_residencia"]).upper()
                    CIUDAD_SEL = "xpath=//*[@id='frmTerceroNatural:ciudadResidenciaInput']"
                    try:
                        await filtros_tab.wait_for_selector(CIUDAD_SEL, timeout=8000)
                        ciudad_input = filtros_tab.locator(CIUDAD_SEL)
                        await ciudad_input.click()
                        await ciudad_input.fill("")
                        await ciudad_input.type(ciudad_plain, delay=150)
                        await filtros_tab.press(CIUDAD_SEL, "Enter")
                    except Exception as e:
                        print(f"[WARN] No se pudo escribir ciudad residencia (existente) ‚Üí {e}", flush=True)

                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:celular']"],
                        CONFIG["celular_tercero"],
                        "Celular tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:telefonoResidencia']"],
                        CONFIG["telefono_residencia_tercero"],
                        "Tel√©fono residencia tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:direccionResidencia']"],
                        CONFIG["direccion_residencia_tercero"],
                        "Direcci√≥n residencia tercero",
                    )
                    await safe_fill(
                        filtros_tab,
                        ["xpath=//*[@id='frmTerceroNatural:email']"],
                        CONFIG["email_tercero"],
                        "Email tercero",
                    )

                    if msg_info_actualizada:
                        do_guardar = False
                        do_cancelar = True
                    else:
                        do_guardar = True
                        do_cancelar = False

                # Guardar / cancelar tercero
                if do_guardar:
                    GUARDAR_SELECTORS = [
                        "xpath=//*[@id='frmTerceroNatural:guardar']",
                        "#frmTerceroNatural\\:guardar",
                    ]
                    btn_found = False
                    for sel in GUARDAR_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, timeout=3000)
                            btn_found = True
                            break
                        except Exception:
                            continue

                    if btn_found:
                        _ = await safe_click(filtros_tab, GUARDAR_SELECTORS, "Bot√≥n frmTerceroNatural:guardar")
                        try:
                            await filtros_tab.evaluate("""
                                () => {
                                    const btn = document.getElementById('frmTerceroNatural:guardar');
                                    if (btn) { btn.scrollIntoView({block:'center'}); btn.click(); }
                                }
                            """)
                        except Exception:
                            pass
                        await wait_for_loader(filtros_tab, timeout=12000)
                    else:
                        print("[ERROR] Bot√≥n frmTerceroNatural:guardar no presente.", flush=True)

                if do_cancelar:
                    CANCELAR_SELECTORS = [
                        "xpath=//*[@id='frmTerceroNatural:cancelar']",
                        "#frmTerceroNatural\\:cancelar",
                    ]
                    cancel_found = False
                    for sel in CANCELAR_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, timeout=3000)
                            cancel_found = True
                            break
                        except Exception:
                            continue

                    if cancel_found:
                        _ = await safe_click(filtros_tab, CANCELAR_SELECTORS, "Bot√≥n frmTerceroNatural:cancelar")
                        try:
                            await filtros_tab.evaluate("""
                                () => {
                                    const btn = document.getElementById('frmTerceroNatural:cancelar');
                                    if (btn) { btn.scrollIntoView({block:'center'}); btn.click(); }
                                }
                            """)
                        except Exception:
                            pass
                        await wait_for_loader(filtros_tab, timeout=12000)
                    else:
                        print("[ERROR] Bot√≥n frmTerceroNatural:cancelar no presente.", flush=True)

                # tipoEnvio, claveLider, agePactado, siguiente
                TIPO_ENVIO_SEL = "#frmDatosFijos\\:componenteTercero\\:tipoEnvio"
                tipo_envio_val = CONFIG.get("tipo_envio", "PE")
                try:
                    _ = await select_richfaces_value(filtros_tab, TIPO_ENVIO_SEL, tipo_envio_val, wait_ajax_ms=1200)
                except Exception as e:
                    print(f"[ERROR] Error al seleccionar tipoEnvio -> {e}", flush=True)

                try:
                    await filtros_tab.evaluate("window.scrollTo(0, document.body.scrollHeight);")
                except Exception:
                    pass

                CLAVE_LIDER_SEL = "#frmDatosFijos\\:claveLider"
                await safe_fill_and_tab(filtros_tab, CLAVE_LIDER_SEL, CONFIG["clave_lider"], "Clave Lider")
                await wait_for_loader(filtros_tab, timeout=8000)

                AGE_PACTADO_SEL = "#frmDatosFijos\\:agePactado"
                await safe_fill_and_tab(filtros_tab, AGE_PACTADO_SEL, CONFIG["age_pactado"], "Age Pactado")
                await wait_for_loader(filtros_tab, timeout=8000)

                CONTINUAR_SELECTORS = [
                    "#frmDatosFijos\\:siguiente",
                    "xpath=//*[@id='frmDatosFijos:siguiente']",
                    "input[value='Continuar ¬ª']",
                ]
                _ = await safe_click(filtros_tab, CONTINUAR_SELECTORS, "Bot√≥n frmDatosFijos:siguiente")
                await wait_for_loader(filtros_tab, timeout=12000)

                # ============================================================
                # SELECT dvPoliza_0_4  -> dejar en "S - Si" con verificaci√≥n y reintentos
                # <select name="formaDatosVariables:dvPoliza_0_4" ...>
                # ============================================================
                DV_POLIZA_SEL = "select[name='formaDatosVariables:dvPoliza_0_4']"
                DV_POLIZA_VALUE = "S"  # value esperado
                DV_POLIZA_TEXT = "S - Si"  # texto visible esperado

                pr(
                    f"Intentando fijar dvPoliza_0_4 a value='{DV_POLIZA_VALUE}' texto='{DV_POLIZA_TEXT}'",
                    "INFO",
                )

                # 1) Esperar que el select exista y sea visible
                try:
                    await filtros_tab.wait_for_selector(DV_POLIZA_SEL, state="visible", timeout=15000)
                    pr("Select dvPoliza_0_4 visible en el DOM.", "INFO")
                except Exception as e:
                    pr(f"[ERROR] dvPoliza_0_4 NO visible en DOM: {e}", "ERROR")
                else:
                    # ---------- FUNCI√ìN DE UN INTENTO ----------
                    async def intentar_fijar_dvPoliza_0_4() -> bool:
                        ok = False

                        # A) Intento directo por value
                        try:
                            await filtros_tab.select_option(DV_POLIZA_SEL, DV_POLIZA_VALUE)
                            pr("[OK] dvPoliza_0_4 fijado v√≠a select_option(value).", "OK")
                            ok = True
                        except Exception as e:
                            pr(f"[WARN] select_option(value) fall√≥ en dvPoliza_0_4: {e}", "WARN")

                        # B) Si no funcion√≥, intentamos por TEXTO (misma l√≥gica que te funciona en autoUso)
                        if not ok:
                            try:
                                ok = await select_option_by_text(
                                    filtros_tab,
                                    DV_POLIZA_SEL,
                                    DV_POLIZA_TEXT,
                                    "dvPoliza_0_4 (S/N)",
                                    wait_ajax_ms=1500,
                                )
                                if ok:
                                    pr("[OK] dvPoliza_0_4 fijado v√≠a select_option_by_text.", "OK")
                            except Exception as e:
                                pr(f"[ERROR] select_option_by_text fall√≥ en dvPoliza_0_4: {e}", "ERROR")

                        # C) √öltimo fallback: JS directo recorriendo options
                        if not ok:
                            try:
                                js_result = await filtros_tab.eval_on_selector(
                                    DV_POLIZA_SEL,
                                    """
                                    (el, args) => {
                                        if (!el) return { ok: false, value: null, text: "" };

                                        const targetVal  = (args.value || "").trim();
                                        const targetText = (args.text  || "").toUpperCase().trim();

                                        const norm = (s) => (s || "")
                                            .replace(/\\u00A0/g, " ")
                                            .replace(/\\s+/g, " ")
                                            .trim()
                                            .toUpperCase();

                                        const opts = Array.from(el.options);

                                        // 1) Buscar por value exacto
                                        let opt = opts.find(o => (o.value || "").trim() === targetVal);

                                        // 2) Si no, por texto normalizado
                                        if (!opt) {
                                            opt = opts.find(o => norm(o.text) === norm(targetText));
                                        }

                                        if (!opt) {
                                            return { ok: false, value: el.value || "", text: (el.options[el.selectedIndex] || {}).text || "" };
                                        }

                                        el.value = opt.value;
                                        el.dispatchEvent(new Event('change', { bubbles: true }));
                                        el.dispatchEvent(new Event('input',  { bubbles: true }));
                                        if (typeof el.blur === 'function') el.blur();

                                        const sel = el.options[el.selectedIndex] || opt;
                                        return {
                                            ok: true,
                                            value: el.value || "",
                                            text: sel ? sel.text : ""
                                        };
                                    }
                                    """,
                                    {"value": DV_POLIZA_VALUE, "text": DV_POLIZA_TEXT},
                                )
                                if js_result and js_result.get("ok"):
                                    pr(
                                        f"[OK] dvPoliza_0_4 fijado por JS -> "
                                        f"value='{js_result.get('value')}', text='{js_result.get('text')}'",
                                        "OK",
                                    )
                                    ok = True
                                else:
                                    pr(f"[WARN] JS no encontr√≥ opci√≥n v√°lida para dvPoliza_0_4.", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS en dvPoliza_0_4 fall√≥: {e}", "ERROR")

                        return ok

                    # ---------- REINTENTOS CON VERIFICACI√ìN REAL ----------
                    max_intentos_poliza = 3
                    ok_final_poliza = False
                    curr_value_poliza, curr_text_poliza = None, ""

                    for intento in range(1, max_intentos_poliza + 1):
                        pr(f"Intento dvPoliza_0_4 #{intento}", "INFO")

                        ok_try = await intentar_fijar_dvPoliza_0_4()

                        # Esperar loader de RichFaces despu√©s de cambiar el select
                        try:
                            await wait_for_loader(filtros_tab, timeout=12000)
                        except Exception:
                            pr("[WARN] Loader no detectado despu√©s del cambio en dvPoliza_0_4.", "WARN")

                        await asyncio.sleep(1)

                        # Leer value Y texto real del DOM
                        try:
                            curr_value_poliza, curr_text_poliza = await filtros_tab.eval_on_selector(
                                DV_POLIZA_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.text : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value_poliza, curr_text_poliza = None, ""
                            pr(f"[ERROR] No se pudo leer estado actual de dvPoliza_0_4: {e}", "ERROR")

                        pr(
                            f"[DEBUG] Estado dvPoliza_0_4 -> value='{curr_value_poliza}', text='{curr_text_poliza}'",
                            "DEBUG",
                        )

                        # Condici√≥n de √©xito: por value o por texto
                        if ok_try and (
                                curr_value_poliza == DV_POLIZA_VALUE
                                or curr_text_poliza.strip().upper() == DV_POLIZA_TEXT.upper()
                        ):
                            pr("[OK] dvPoliza_0_4 qued√≥ fijado correctamente en 'S - Si'.", "OK")
                            ok_final_poliza = True
                            break
                        else:
                            pr(
                                f"[WARN] dvPoliza_0_4 a√∫n NO coincide (esperado value='{DV_POLIZA_VALUE}', "
                                f"text='{DV_POLIZA_TEXT}') ‚Üí reintentando‚Ä¶",
                                "WARN",
                            )
                            await asyncio.sleep(1)

                    if not ok_final_poliza:
                        pr(
                            "[ERROR] dvPoliza_0_4 NO se pudo fijar en 'S - Si' "
                            f"(value='{DV_POLIZA_VALUE}') tras {max_intentos_poliza} intentos.",
                            "ERROR",
                        )

                # ============================================================
                # INPUT dvPoliza_0_5  -> poner "100" y disparar onchange
                # <input type="text" name="formaDatosVariables:dvPoliza_0_5" ...>
                # ============================================================
                INPUT_POLIZA_5_SEL = "input[name='formaDatosVariables:dvPoliza_0_5']"
                INPUT_POLIZA_5_VALUE = "100"

                pr(f"Llenando dvPoliza_0_5 con '{INPUT_POLIZA_5_VALUE}'", "INFO")

                try:
                    await filtros_tab.wait_for_selector(INPUT_POLIZA_5_SEL, state="visible", timeout=15000)
                    await filtros_tab.fill(INPUT_POLIZA_5_SEL, INPUT_POLIZA_5_VALUE)
                    pr("[OK] dvPoliza_0_5 rellenado con '100'.", "OK")

                    # Enviar Tab para disparar onchange / blur
                    try:
                        await filtros_tab.press(INPUT_POLIZA_5_SEL, "Tab")
                        pr("Tab enviado en dvPoliza_0_5.", "INFO")
                    except Exception as e:
                        pr(f"[WARN] No se pudo enviar Tab en dvPoliza_0_5: {e}", "WARN")

                    # Esperar loader despu√©s del cambio
                    try:
                        await wait_for_loader(filtros_tab, timeout=10000)
                        pr("Loader tras dvPoliza_0_5 completado.", "INFO")
                    except Exception:
                        pr("[WARN] Loader no detectado despu√©s de dvPoliza_0_5.", "WARN")

                except Exception as e:
                    pr(f"[ERROR] No se pudo llenar dvPoliza_0_5 -> {e}", "ERROR")

                ##datos de la comision
                # formaDatosVariables:continuar
                FDV_CONT_SELECTORS = [
                    "#formaDatosVariables\\:continuar",
                    "xpath=//*[@id='formaDatosVariables:continuar']",
                    "input[name='formaDatosVariables:continuar']",
                ]
                _ = await safe_click(
                    filtros_tab,
                    FDV_CONT_SELECTORS,
                    "Bot√≥n formaDatosVariables:continuar (primer click)",
                )
                await wait_for_loader(filtros_tab, timeout=12000)

                # ===============================
                # Placa + datos de veh√≠culo
                # ===============================
                try:
                    AUTO_PLACA_SEL = "#frmRiesgosPoliza\\:autoPlaca"
                    await filtros_tab.wait_for_selector(AUTO_PLACA_SEL, timeout=10000)
                    await filtros_tab.fill(AUTO_PLACA_SEL, CONFIG["placa"])
                    await filtros_tab.press(AUTO_PLACA_SEL, "Tab")

                    try:
                        await filtros_tab.wait_for_selector(
                            "#statusPanel_container",
                            state="visible",
                            timeout=10000,
                        )
                    except PlaywrightTimeoutError:
                        pass

                    await wait_for_loader(filtros_tab, timeout=20000)

                    # ======================================================================
                    #  DATOS DEL VEH√çCULO ‚Äì RELLENAR SOLO SI EST√ÅN VAC√çOS
                    #  - Marca / Uso / Modelo / Color / Motor / Chasis / Km / Cobertura
                    #  - Suma asegurada: SIEMPRE validar que quede igual al valor esperado
                    # ======================================================================

                    MARCA_SEL = "#frmRiesgosPoliza\\:autoMarcaInput"
                    await filtros_tab.wait_for_selector(MARCA_SEL, timeout=8000)

                    marca_val = (await filtros_tab.input_value(MARCA_SEL)).strip()
                    print(f"[INFO] Valor de autoMarcaInput despu√©s de la placa: '{marca_val}'", flush=True)

                    # Helper gen√©rico para leer value (text inputs)
                    async def leer_valor_input(sel: str) -> str:
                        try:
                            return await filtros_tab.eval_on_selector(
                                sel,
                                "el => el ? (el.value || '').trim() : ''",
                            ) or ""
                        except Exception as e:
                            print(f"[WARN] No se pudo leer valor de '{sel}': {e}", flush=True)
                            return ""

                    # Helper gen√©rico para leer value (select)
                    async def leer_valor_select(sel: str) -> str:
                        try:
                            return await filtros_tab.eval_on_selector(
                                sel,
                                "el => el ? (el.value || '').trim() : ''",
                            ) or ""
                        except Exception as e:
                            print(f"[WARN] No se pudo leer valor (select) de '{sel}': {e}", flush=True)
                            return ""

                    if not marca_val:
                        print("[INFO] autoMarcaInput vac√≠o ‚Üí llenando datos manuales de veh√≠culo‚Ä¶", flush=True)

                        marca_manual = (CONFIG.get("FASECOLDA") or "").strip()

                        if not marca_manual:
                            print("[WARN] CONFIG['FASECOLDA'] vac√≠o, no se llena marca manual.", flush=True)
                        else:
                            MARCA_SEL = "#frmRiesgosPoliza\\:autoMarcaInput"

                            # --------------------------------------------------------------
                            # üî• REINTENTOS PARA ESCRIBIR MARCA Y VALIDAR QUE QUED√ì FIJA
                            # --------------------------------------------------------------
                            max_intentos_marca = 4
                            ok_marca = False

                            for intento in range(1, max_intentos_marca + 1):
                                print(f"[INFO] Intento #{intento} para fijar autoMarcaInput='{marca_manual}'",
                                      flush=True)

                                try:
                                    await filtros_tab.wait_for_selector(MARCA_SEL, timeout=10000)
                                    marca_input = filtros_tab.locator(MARCA_SEL)

                                    # 1) Limpiar campo
                                    await marca_input.click()
                                    await marca_input.fill("")
                                    await asyncio.sleep(0.15)

                                    # 2) Escribir manual con delay humano
                                    await marca_input.type(marca_manual, delay=80)

                                    # 3) Enviar ENTER + ENTER + TAB (para cerrar suggest y salir del campo)
                                    try:
                                        await filtros_tab.press(MARCA_SEL, "Enter")
                                        await asyncio.sleep(0.15)
                                        await filtros_tab.press(MARCA_SEL, "Enter")
                                        await asyncio.sleep(0.15)
                                        await filtros_tab.press(MARCA_SEL, "Tab")
                                        print("[INFO] ENTER, ENTER y TAB enviados a autoMarcaInput.", flush=True)
                                    except Exception as e:
                                        print(f"[WARN] No se pudieron enviar teclas (Enter/Tab) en autoMarcaInput: {e}",
                                              flush=True)

                                    # 4) Fallback JS para asegurar change/input + blur
                                    try:
                                        js_ok = await filtros_tab.evaluate(
                                            """
                                            (sel) => {
                                                const el = document.querySelector(sel);
                                                if (!el) return false;
                                                el.dispatchEvent(new Event('change', { bubbles: true }));
                                                el.dispatchEvent(new Event('input',  { bubbles: true }));
                                                if (typeof el.blur === 'function') {
                                                    el.blur();
                                                }
                                                return true;
                                            }
                                            """,
                                            MARCA_SEL,
                                        )
                                        if not js_ok:
                                            print("[WARN] JS no pudo forzar change/blur en autoMarcaInput.", flush=True)
                                    except Exception as e:
                                        print(f"[WARN] Fallback JS change/blur fall√≥ en autoMarcaInput: {e}",
                                              flush=True)

                                    # 5) Loader (si existe)
                                    try:
                                        await wait_for_loader(filtros_tab, timeout=8000)
                                    except Exception:
                                        print("[WARN] Loader no detectado tras autoMarcaInput (ok).", flush=True)

                                    # 6) Espera peque√±a antes de validar
                                    await asyncio.sleep(0.8)

                                    # 7) VALIDAR VALOR REAL EN EL DOM
                                    try:
                                        marca_val_now = (await filtros_tab.input_value(MARCA_SEL)).strip()
                                    except Exception as e:
                                        marca_val_now = ""
                                        print(f"[ERROR] No se pudo leer valor actual de autoMarcaInput: {e}",
                                              flush=True)

                                    print(f"[DEBUG] Valor actual en autoMarcaInput='{marca_val_now}'", flush=True)

                                    if marca_val_now and (marca_manual.lower() in marca_val_now.lower()):
                                        print("[OK] autoMarcaInput qued√≥ correctamente establecido.", flush=True)
                                        ok_marca = True
                                        break
                                    else:
                                        print("[WARN] autoMarcaInput NO qued√≥ bien. Reintentando‚Ä¶", flush=True)
                                        await asyncio.sleep(1.0)

                                except Exception as e:
                                    print(f"[ERROR] Fall√≥ intento de llenado autoMarcaInput: {e}", flush=True)

                            # Si NO qued√≥ bien despu√©s de varios intentos
                            if not ok_marca:
                                print(
                                    f"[ERROR] No se pudo fijar autoMarcaInput a '{marca_manual}' despu√©s de {max_intentos_marca} intentos.",
                                    flush=True
                                )
                            else:
                                print("[OK] Marca manual completada con √©xito.", flush=True)

                        print("[INFO] autoMarcaInput ya tiene datos, no se llena manualmente.", flush=True)

                        # COLOR
                        COLOR_SEL = "#frmRiesgosPoliza\\:autoColor"
                        color_val_cfg = (CONFIG.get("auto_color") or "").strip()
                        if color_val_cfg:
                            curr_color = await leer_valor_input(COLOR_SEL)
                            if not curr_color:
                                await safe_fill(
                                    filtros_tab,
                                    [
                                        COLOR_SEL,
                                        "xpath=//*[@id='frmRiesgosPoliza:autoColor']",
                                    ],
                                    color_val_cfg,
                                    "Color",
                                )
                            else:
                                print(f"[INFO] Color ya tiene valor '{curr_color}', no se modifica.", flush=True)

                        # COBERTURA
                        cobertura_val_cfg = (CONFIG.get("auto_cobertura_value") or "").strip()
                        COB_SEL = "#frmRiesgosPoliza\\:autoCobertura"
                        if cobertura_val_cfg:
                            curr_cob = await leer_valor_select(COB_SEL)
                            if not curr_cob:
                                ok_cob = await select_richfaces_value(
                                    filtros_tab,
                                    COB_SEL,
                                    cobertura_val_cfg,
                                    wait_ajax_ms=1200,
                                )
                                if not ok_cob:
                                    print(
                                        "[WARN] No se pudo seleccionar cobertura por value, intento por texto '43 -'",
                                        flush=True,
                                    )
                                    try:
                                        await filtros_tab.evaluate("""
                                                                    () => {
                                                                        const s = document.querySelector('#frmRiesgosPoliza\\\\:autoCobertura');
                                                                        if (!s) return;
                                                                        const opts = [...s.options];
                                                                        const opt = opts.find(o => o.text.trim().startsWith('43 -'));
                                                                        if (opt) {
                                                                            s.value = opt.value;
                                                                            s.dispatchEvent(new Event('change', { bubbles: true }));
                                                                            s.dispatchEvent(new Event('input',  { bubbles: true }));
                                                                            s.blur && s.blur();
                                                                        }
                                                                    }
                                                                """)
                                    except Exception as e:
                                        print(f"[ERROR] No se pudo seleccionar cobertura 43 -> {e}", flush=True)
                            else:
                                print(f"[INFO] autoCobertura ya tiene value='{curr_cob}', no se modifica.", flush=True)
                        else:
                            print("[WARN] auto_cobertura_value vac√≠o en CONFIG.", flush=True)

                        # USO (cuando marca viene ya cargada) ‚Äì s√≥lo si est√° vac√≠o o en -1 / --Seleccione--
                        uso_text = (CONFIG.get("auto_uso_value") or "31 - PARTICULAR FAMILIAR").strip()
                        USO_SEL = "#frmRiesgosPoliza\\:autoUso"

                        if uso_text:
                            curr_uso = await leer_valor_select(USO_SEL)
                            # Normalizamos valor actual
                            curr_uso_norm = (curr_uso or "").strip() if curr_uso is not None else ""

                            # Consideramos "vac√≠o" si:
                            # - cadena vac√≠a
                            # - "-1"
                            # - texto tipo "--Seleccione--"
                            is_empty_uso = (
                                    curr_uso_norm == "" or
                                    curr_uso_norm == "-1" or
                                    curr_uso_norm.startswith("--Seleccione")
                            )

                            if is_empty_uso:
                                print(
                                    f"[INFO] autoUso vac√≠o o en valor por defecto ('{curr_uso_norm}') ‚Üí intentando seleccionar '{uso_text}'",
                                    flush=True,
                                )
                                ok_uso = await select_option_by_text(
                                    filtros_tab,
                                    USO_SEL,
                                    uso_text,
                                    "Uso del veh√≠culo (autoUso)",
                                    wait_ajax_ms=1500,
                                )
                                if not ok_uso:
                                    try:
                                        curr_uso = await leer_valor_select(USO_SEL)
                                        print(
                                            f"[WARN] autoUso no se pudo fijar en '{uso_text}', value actual='{curr_uso}'",
                                            flush=True,
                                        )
                                    except Exception as e:
                                        print(f"[ERROR] No se pudo leer valor actual de autoUso -> {e}", flush=True)
                            else:
                                print(f"[INFO] autoUso ya tiene value='{curr_uso_norm}', no se modifica.", flush=True)
                        else:
                            print("[INFO] CONFIG['auto_uso_value'] vac√≠o, no se selecciona uso.", flush=True)

                        # ---------------- MODELO (select) ‚Äì s√≥lo si value vac√≠o o en -1 / --Seleccione--
                        modelo_text = (CONFIG.get("auto_modelo_value") or "").strip()
                        MODELO_SEL = "#frmRiesgosPoliza\\:autoModelo"

                        if modelo_text:
                            curr_modelo = await leer_valor_select(MODELO_SEL)
                            curr_modelo_norm = (curr_modelo or "").strip() if curr_modelo is not None else ""

                            is_empty_modelo = (
                                    curr_modelo_norm == "" or
                                    curr_modelo_norm == "-1" or
                                    curr_modelo_norm.startswith("--Seleccione")
                            )

                            if is_empty_modelo:
                                print(
                                    f"[INFO] Modelo vac√≠o o por defecto ('{curr_modelo_norm}') ‚Üí intentando seleccionar autoModelo='{modelo_text}'",
                                    flush=True,
                                )

                                # 1) Intento con helper gen√©rico (si hace match por texto visible)
                                ok_modelo = await select_option_by_text(
                                    filtros_tab,
                                    MODELO_SEL,
                                    modelo_text,
                                    "Modelo del veh√≠culo (autoModelo)",
                                    wait_ajax_ms=1500,
                                )

                                # 2) Fallback con JS si el helper falla
                                if not ok_modelo:
                                    print("[WARN] select_option_by_text no pudo fijar modelo, intento fallback JS‚Ä¶",
                                          flush=True)
                                    try:
                                        await filtros_tab.evaluate(
                                            """
                                            (sel, target) => {
                                                const s = document.querySelector(sel);
                                                if (!s) return false;
                                                const opts = Array.from(s.options || []);
                                                const t = (target || "").trim();

                                                // Prioridad 1: match exacto por texto
                                                let opt = opts.find(o => o.text.trim() === t);

                                                // Prioridad 2: texto que empiece por el target (ej: "2025" -> "2025 - MODELO 2025")
                                                if (!opt) {
                                                    opt = opts.find(o => o.text.trim().startsWith(t + " "));
                                                }

                                                if (!opt) return false;

                                                s.value = opt.value;

                                                // Disparar eventos necesarios para RichFaces / JSF
                                                const evtChange = new Event('change', { bubbles: true });
                                                const evtInput  = new Event('input',  { bubbles: true });
                                                s.dispatchEvent(evtChange);
                                                s.dispatchEvent(evtInput);
                                                if (typeof s.blur === 'function') {
                                                    s.blur();
                                                }
                                                return true;
                                            }
                                            """,
                                            MODELO_SEL,
                                            modelo_text,
                                        )
                                        # Esperar AJAX si aplica
                                        try:
                                            await wait_for_loader(filtros_tab, timeout=8000)
                                        except Exception:
                                            print("[WARN] Loader no detectado despu√©s de autoModelo (ok).", flush=True)

                                        # Validar nuevamente
                                        curr_modelo2 = await leer_valor_select(MODELO_SEL)
                                        curr_modelo2_norm = (curr_modelo2 or "").strip()
                                        print(f"[DEBUG] autoModelo value despu√©s de fallback='{curr_modelo2_norm}'",
                                              flush=True)

                                        if curr_modelo2_norm and not curr_modelo2_norm.startswith("--Seleccione"):
                                            print("[OK] autoModelo qued√≥ correctamente establecido por fallback JS.",
                                                  flush=True)
                                            ok_modelo = True
                                        else:
                                            print("[ERROR] autoModelo sigue sin valor v√°lido tras fallback JS.",
                                                  flush=True)

                                    except Exception as e:
                                        print(f"[ERROR] Fallback JS para autoModelo fall√≥ -> {e}", flush=True)

                                if not ok_modelo:
                                    print(
                                        f"[ERROR] autoModelo no se pudo fijar en '{modelo_text}' (ni helper ni fallback js).",
                                        flush=True,
                                    )
                            else:
                                print(f"[INFO] autoModelo ya tiene value='{curr_modelo_norm}', no se modifica.",
                                      flush=True)
                        else:
                            print("[INFO] CONFIG['auto_modelo_value'] vac√≠o, no se selecciona modelo.", flush=True)

                        # SUMA ASEGURADA ‚Äì MISMA L√ìGICA DE VALIDACI√ìN CON REINTENTOS
                        suma_val_cfg = (CONFIG.get("VALOR ASEGURADO") or "").strip()
                        if suma_val_cfg:
                            SUMA_SEL = "#frmRiesgosPoliza\\:autoSumaAseg"
                            try:
                                await filtros_tab.wait_for_selector(SUMA_SEL, timeout=8000)
                                max_intentos_suma = 3
                                ok_suma = False

                                for intento in range(1, max_intentos_suma + 1):
                                    print(f"[INFO] Intento #{intento} para fijar autoSumaAseg='{suma_val_cfg}'",
                                          flush=True)
                                    await filtros_tab.fill(SUMA_SEL, suma_val_cfg)
                                    try:
                                        await filtros_tab.press(SUMA_SEL, "Tab")
                                    except Exception:
                                        pass

                                    try:
                                        await wait_for_loader(filtros_tab, timeout=8000)
                                    except Exception:
                                        print("[WARN] Loader no detectado despu√©s de autoSumaAseg.", flush=True)

                                    await asyncio.sleep(0.5)
                                    curr_suma = await leer_valor_input(SUMA_SEL)
                                    print(f"[DEBUG] autoSumaAseg actual='{curr_suma}'", flush=True)

                                    if curr_suma == suma_val_cfg:
                                        print("[OK] autoSumaAseg qued√≥ correctamente.", flush=True)
                                        ok_suma = True
                                        break
                                    else:
                                        print("[WARN] autoSumaAseg a√∫n no coincide, reintentando‚Ä¶", flush=True)

                                if not ok_suma:
                                    print(
                                        f"[ERROR] autoSumaAseg NO qued√≥ en '{suma_val_cfg}' tras {max_intentos_suma} intentos.",
                                        flush=True,
                                    )
                            except Exception as e:
                                print(f"[WARN] No se pudo procesar autoSumaAseg -> {e}", flush=True)

                    # ============================================================
                    # Si la marca YA tiene datos (flujo ‚Äúautom√°tico‚Äù)
                    # ‚Äì Aun as√≠ se rellenan algunos campos s√≥lo si est√°n vac√≠os
                    # ============================================================
                    else:
                        print("[INFO] autoMarcaInput ya tiene datos, no se llena manualmente.", flush=True)

                        # COLOR
                        COLOR_SEL = "#frmRiesgosPoliza\\:autoColor"
                        color_val_cfg = (CONFIG.get("auto_color") or "").strip()
                        if color_val_cfg:
                            curr_color = await leer_valor_input(COLOR_SEL)
                            if not curr_color:
                                await safe_fill(
                                    filtros_tab,
                                    [
                                        COLOR_SEL,
                                        "xpath=//*[@id='frmRiesgosPoliza:autoColor']",
                                    ],
                                    color_val_cfg,
                                    "Color",
                                )
                            else:
                                print(f"[INFO] Color ya tiene valor '{curr_color}', no se modifica.", flush=True)

                        # COBERTURA
                        cobertura_val_cfg = (CONFIG.get("auto_cobertura_value") or "").strip()
                        COB_SEL = "#frmRiesgosPoliza\\:autoCobertura"
                        if cobertura_val_cfg:
                            curr_cob = await leer_valor_select(COB_SEL)
                            if not curr_cob:
                                ok_cob = await select_richfaces_value(
                                    filtros_tab,
                                    COB_SEL,
                                    cobertura_val_cfg,
                                    wait_ajax_ms=1200,
                                )
                                if not ok_cob:
                                    print(
                                        "[WARN] No se pudo seleccionar cobertura por value, intento por texto '43 -'",
                                        flush=True,
                                    )
                                    try:
                                        await filtros_tab.evaluate("""
                                            () => {
                                                const s = document.querySelector('#frmRiesgosPoliza\\\\:autoCobertura');
                                                if (!s) return;
                                                const opts = [...s.options];
                                                const opt = opts.find(o => o.text.trim().startsWith('43 -'));
                                                if (opt) {
                                                    s.value = opt.value;
                                                    s.dispatchEvent(new Event('change', { bubbles: true }));
                                                    s.dispatchEvent(new Event('input',  { bubbles: true }));
                                                    s.blur && s.blur();
                                                }
                                            }
                                        """)
                                    except Exception as e:
                                        print(f"[ERROR] No se pudo seleccionar cobertura 43 -> {e}", flush=True)
                            else:
                                print(f"[INFO] autoCobertura ya tiene value='{curr_cob}', no se modifica.", flush=True)
                        else:
                            print("[WARN] auto_cobertura_value vac√≠o en CONFIG.", flush=True)

                        # USO (cuando marca viene ya cargada) ‚Äì s√≥lo si est√° vac√≠o o en -1 / --Seleccione--
                        uso_text = (CONFIG.get("auto_uso_value") or "31 - PARTICULAR FAMILIAR").strip()
                        USO_SEL = "#frmRiesgosPoliza\\:autoUso"

                        if uso_text:
                            curr_uso = await leer_valor_select(USO_SEL)
                            # Normalizamos valor actual
                            curr_uso_norm = (curr_uso or "").strip() if curr_uso is not None else ""

                            # Consideramos "vac√≠o" si:
                            # - cadena vac√≠a
                            # - "-1"
                            # - texto tipo "--Seleccione--"
                            is_empty_uso = (
                                    curr_uso_norm == "" or
                                    curr_uso_norm == "-1" or
                                    curr_uso_norm.startswith("--Seleccione")
                            )

                            if is_empty_uso:
                                print(
                                    f"[INFO] autoUso vac√≠o o en valor por defecto ('{curr_uso_norm}') ‚Üí intentando seleccionar '{uso_text}'",
                                    flush=True,
                                )
                                ok_uso = await select_option_by_text(
                                    filtros_tab,
                                    USO_SEL,
                                    uso_text,
                                    "Uso del veh√≠culo (autoUso)",
                                    wait_ajax_ms=1500,
                                )
                                if not ok_uso:
                                    try:
                                        curr_uso = await leer_valor_select(USO_SEL)
                                        print(
                                            f"[WARN] autoUso no se pudo fijar en '{uso_text}', value actual='{curr_uso}'",
                                            flush=True,
                                        )
                                    except Exception as e:
                                        print(f"[ERROR] No se pudo leer valor actual de autoUso -> {e}", flush=True)
                            else:
                                print(f"[INFO] autoUso ya tiene value='{curr_uso_norm}', no se modifica.", flush=True)
                        else:
                            print("[INFO] CONFIG['auto_uso_value'] vac√≠o, no se selecciona uso.", flush=True)

                        # ---------------- MODELO (select) ‚Äì s√≥lo si value vac√≠o o en -1 / --Seleccione--
                        modelo_text = (CONFIG.get("auto_modelo_value") or "").strip()
                        MODELO_SEL = "#frmRiesgosPoliza\\:autoModelo"

                        if modelo_text:
                            curr_modelo = await leer_valor_select(MODELO_SEL)
                            curr_modelo_norm = (curr_modelo or "").strip() if curr_modelo is not None else ""

                            is_empty_modelo = (
                                    curr_modelo_norm == "" or
                                    curr_modelo_norm == "-1" or
                                    curr_modelo_norm.startswith("--Seleccione")
                            )

                            if is_empty_modelo:
                                print(
                                    f"[INFO] Modelo vac√≠o o por defecto ('{curr_modelo_norm}') ‚Üí intentando seleccionar autoModelo='{modelo_text}'",
                                    flush=True,
                                )

                                # 1) Intento con helper gen√©rico (si hace match por texto visible)
                                ok_modelo = await select_option_by_text(
                                    filtros_tab,
                                    MODELO_SEL,
                                    modelo_text,
                                    "Modelo del veh√≠culo (autoModelo)",
                                    wait_ajax_ms=1500,
                                )

                                # 2) Fallback con JS si el helper falla
                                if not ok_modelo:
                                    print("[WARN] select_option_by_text no pudo fijar modelo, intento fallback JS‚Ä¶",
                                          flush=True)
                                    try:
                                        await filtros_tab.evaluate(
                                            """
                                            (sel, target) => {
                                                const s = document.querySelector(sel);
                                                if (!s) return false;
                                                const opts = Array.from(s.options || []);
                                                const t = (target || "").trim();

                                                // Prioridad 1: match exacto por texto
                                                let opt = opts.find(o => o.text.trim() === t);

                                                // Prioridad 2: texto que empiece por el target (ej: "2025" -> "2025 - MODELO 2025")
                                                if (!opt) {
                                                    opt = opts.find(o => o.text.trim().startsWith(t + " "));
                                                }

                                                if (!opt) return false;

                                                s.value = opt.value;

                                                // Disparar eventos necesarios para RichFaces / JSF
                                                const evtChange = new Event('change', { bubbles: true });
                                                const evtInput  = new Event('input',  { bubbles: true });
                                                s.dispatchEvent(evtChange);
                                                s.dispatchEvent(evtInput);
                                                if (typeof s.blur === 'function') {
                                                    s.blur();
                                                }
                                                return true;
                                            }
                                            """,
                                            MODELO_SEL,
                                            modelo_text,
                                        )
                                        # Esperar AJAX si aplica
                                        try:
                                            await wait_for_loader(filtros_tab, timeout=8000)
                                        except Exception:
                                            print("[WARN] Loader no detectado despu√©s de autoModelo (ok).", flush=True)

                                        # Validar nuevamente
                                        curr_modelo2 = await leer_valor_select(MODELO_SEL)
                                        curr_modelo2_norm = (curr_modelo2 or "").strip()
                                        print(f"[DEBUG] autoModelo value despu√©s de fallback='{curr_modelo2_norm}'",
                                              flush=True)

                                        if curr_modelo2_norm and not curr_modelo2_norm.startswith("--Seleccione"):
                                            print("[OK] autoModelo qued√≥ correctamente establecido por fallback JS.",
                                                  flush=True)
                                            ok_modelo = True
                                        else:
                                            print("[ERROR] autoModelo sigue sin valor v√°lido tras fallback JS.",
                                                  flush=True)

                                    except Exception as e:
                                        print(f"[ERROR] Fallback JS para autoModelo fall√≥ -> {e}", flush=True)

                                if not ok_modelo:
                                    print(
                                        f"[ERROR] autoModelo no se pudo fijar en '{modelo_text}' (ni helper ni fallback js).",
                                        flush=True,
                                    )
                            else:
                                print(f"[INFO] autoModelo ya tiene value='{curr_modelo_norm}', no se modifica.",
                                      flush=True)
                        else:
                            print("[INFO] CONFIG['auto_modelo_value'] vac√≠o, no se selecciona modelo.", flush=True)

                        # SUMA ASEGURADA ‚Äì MISMA L√ìGICA DE VALIDACI√ìN CON REINTENTOS
                        suma_val_cfg = (CONFIG.get("VALOR ASEGURADO") or "").strip()
                        if suma_val_cfg:
                            SUMA_SEL = "#frmRiesgosPoliza\\:autoSumaAseg"
                            try:
                                await filtros_tab.wait_for_selector(SUMA_SEL, timeout=8000)
                                max_intentos_suma = 3
                                ok_suma = False

                                for intento in range(1, max_intentos_suma + 1):
                                    print(f"[INFO] Intento #{intento} para fijar autoSumaAseg='{suma_val_cfg}'",
                                          flush=True)
                                    await filtros_tab.fill(SUMA_SEL, suma_val_cfg)
                                    try:
                                        await filtros_tab.press(SUMA_SEL, "Tab")
                                    except Exception:
                                        pass

                                    try:
                                        await wait_for_loader(filtros_tab, timeout=8000)
                                    except Exception:
                                        print("[WARN] Loader no detectado despu√©s de autoSumaAseg.", flush=True)

                                    await asyncio.sleep(0.5)
                                    curr_suma = await leer_valor_input(SUMA_SEL)
                                    print(f"[DEBUG] autoSumaAseg actual='{curr_suma}'", flush=True)

                                    if curr_suma == suma_val_cfg:
                                        print("[OK] autoSumaAseg qued√≥ correctamente.", flush=True)
                                        ok_suma = True
                                        break
                                    else:
                                        print("[WARN] autoSumaAseg a√∫n no coincide, reintentando‚Ä¶", flush=True)

                                if not ok_suma:
                                    print(
                                        f"[ERROR] autoSumaAseg NO qued√≥ en '{suma_val_cfg}' tras {max_intentos_suma} intentos.",
                                        flush=True,
                                    )
                            except Exception as e:
                                print(f"[WARN] No se pudo procesar autoSumaAseg -> {e}", flush=True)

                    # ============================================================
                    # SELECT: Tipo de documento del conductor (autoTipoDoc)
                    # <select id="frmRiesgosPoliza:autoTipoDoc" ...>
                    # Usa la MISMA l√≥gica que Estado Civil (autoCondCivil)
                    # ============================================================

                    # ============================================================
                    # SELECT: Tipo de documento del conductor (autoTipoDoc)
                    # <select id="frmRiesgosPoliza:autoTipoDoc" ...>
                    # Mismo patr√≥n que TDOC_SEL (TipoDocumento tomador)
                    # ============================================================

                    AUTO_TDOC_SEL = "select#frmRiesgosPoliza\\:autoTipoDoc"

                    # SOLO VALUE (por ejemplo: "CC", "CE", "TI", "NT"...)
                    AUTO_TDOC_VALUE = (CONFIG.get("TIPO_DOC_ASEGURADO") or "CC").strip().upper()

                    pr(f"Intentando fijar autoTipoDoc a value='{AUTO_TDOC_VALUE}'", "INFO")

                    if not AUTO_TDOC_VALUE:
                        pr("TIPO_DOC_ASEGURADO viene vac√≠o, no se puede fijar autoTipoDoc.", "WARN")
                    else:
                        # 1) Esperar que exista y sea visible
                        try:
                            await filtros_tab.wait_for_selector(AUTO_TDOC_SEL, state="visible", timeout=15000)
                            pr("Select autoTipoDoc visible.", "INFO")
                        except Exception as e:
                            pr(f"[ERROR] autoTipoDoc no visible en DOM: {e}", "ERROR")
                            # si aqu√≠ falla, no tiene sentido seguir intentando
                            # puedes hacer raise si quieres cortar el flujo:
                            # raise
                        else:
                            # 2) Reintentos para fijar el valor
                            max_intentos_tdoc = 4
                            ok_tdoc = False

                            for intento in range(1, max_intentos_tdoc + 1):
                                pr(f"[INTENTO {intento}] Fijando autoTipoDoc a '{AUTO_TDOC_VALUE}'‚Ä¶", "INFO")
                                try:
                                    # Intento principal: select_option por value
                                    try:
                                        await filtros_tab.select_option(AUTO_TDOC_SEL, AUTO_TDOC_VALUE)
                                        pr("select_option() ejecutado sobre autoTipoDoc.", "DEBUG")
                                    except Exception as e:
                                        pr(f"[WARN] select_option() fall√≥ en intento #{intento}: {e}", "WARN")

                                    # (Opcional) espera de loader si ese combo dispara AJAX
                                    try:
                                        await wait_for_loader(filtros_tab, timeout=8000)
                                    except Exception:
                                        pr("Loader no detectado despu√©s de autoTipoDoc (ok).", "DEBUG")

                                    # Peque√±a espera para que el DOM se estabilice
                                    await asyncio.sleep(0.5)

                                    # Leer el value actual del select
                                    try:
                                        curr_tdoc_val = await filtros_tab.eval_on_selector(
                                            AUTO_TDOC_SEL,
                                            "el => (el.value || '').trim()"
                                        )
                                    except Exception as e:
                                        curr_tdoc_val = ""
                                        pr(f"[ERROR] No se pudo leer value actual de autoTipoDoc: {e}", "ERROR")

                                    pr(f"[DEBUG] autoTipoDoc value actual='{curr_tdoc_val}'", "DEBUG")

                                    if curr_tdoc_val and curr_tdoc_val.upper() == AUTO_TDOC_VALUE.upper():
                                        pr("[OK] autoTipoDoc qued√≥ correctamente establecido.", "INFO")
                                        ok_tdoc = True
                                        break
                                    else:
                                        pr(
                                            f"[WARN] autoTipoDoc a√∫n no coincide con '{AUTO_TDOC_VALUE}' (actual='{curr_tdoc_val}').",
                                            "WARN",
                                        )
                                        await asyncio.sleep(1.0)

                                except Exception as e:
                                    pr(f"[ERROR] Error en intento #{intento} al fijar autoTipoDoc: {e}", "ERROR")
                                    await asyncio.sleep(1.0)

                            if not ok_tdoc:
                                pr(
                                    f"[ERROR] autoTipoDoc NO se pudo fijar en '{AUTO_TDOC_VALUE}' tras {max_intentos_tdoc} intentos.",
                                    "ERROR",
                                )
                                # Si quieres que el flujo se DETENGA si no se fija correctamente, descomenta:
                                # raise RuntimeError(f"autoTipoDoc no qued√≥ en '{AUTO_TDOC_VALUE}'")

                    # ======================================================================
                    # AUTO ‚Äì DOCUMENTO DEL ASEGURADO (frmRiesgosPoliza:autoNumDocu)
                    # Usa CONFIG["ASEGURADO DOCUMENTO"] como valor objetivo
                    # ======================================================================

                    AUTO_DOC_SEL = "#frmRiesgosPoliza\\:autoNumDocu"
                    doc_cfg = (CONFIG.get("ASEGURADO DOCUMENTO") or "").strip()

                    if not doc_cfg:
                        print("[WARN] CONFIG['ASEGURADO DOCUMENTO'] vac√≠o, no se escribe autoNumDocu.", flush=True)
                    else:
                        try:
                            await filtros_tab.wait_for_selector(AUTO_DOC_SEL, timeout=10000)
                            print("[INFO] Campo autoNumDocu visible.", flush=True)
                        except Exception as e:
                            print(f"[ERROR] autoNumDocu no visible en DOM: {e}", flush=True)
                        else:
                            # Helper para leer el valor actual del input
                            async def leer_auto_doc() -> str:
                                try:
                                    return await filtros_tab.eval_on_selector(
                                        AUTO_DOC_SEL,
                                        "el => el ? (el.value || '').trim() : ''",
                                    ) or ""
                                except Exception as e:
                                    print(f"[WARN] No se pudo leer valor de autoNumDocu: {e}", flush=True)
                                    return ""

                            max_intentos_doc = 3
                            ok_doc = False

                            for intento in range(1, max_intentos_doc + 1):
                                print(
                                    f"[INFO] Intento #{intento} para fijar autoNumDocu='{doc_cfg}'",
                                    flush=True,
                                )

                                # Leer valor actual
                                valor_actual = await leer_auto_doc()
                                print(f"[DEBUG] Valor actual autoNumDocu antes de escribir: '{valor_actual}'",
                                      flush=True)

                                # Si ya coincide, no hacemos nada m√°s
                                if valor_actual == doc_cfg:
                                    print("[OK] autoNumDocu ya coincide con el valor de CONFIG, no se modifica.",
                                          flush=True)
                                    ok_doc = True
                                    break

                                # Escribir el valor objetivo
                                try:
                                    input_doc = filtros_tab.locator(AUTO_DOC_SEL)
                                    await input_doc.click()
                                    await input_doc.fill("")  # limpiar
                                    await input_doc.type(doc_cfg, delay=60)

                                    # Disparar blur/change con Tab (como si fuera usuario)
                                    try:
                                        await filtros_tab.press(AUTO_DOC_SEL, "Tab")
                                    except Exception:
                                        # Si por alguna raz√≥n falla el Tab, al menos hacemos blur desde JS
                                        try:
                                            await filtros_tab.eval_on_selector(
                                                AUTO_DOC_SEL,
                                                "el => el && el.blur && el.blur()",
                                            )
                                        except Exception:
                                            pass

                                    # Esperar loader RichFaces (pero sin bloquear si no aparece)
                                    try:
                                        await wait_for_loader(filtros_tab, timeout=12000)
                                    except Exception:
                                        print("[WARN] Loader no detectado despu√©s de autoNumDocu (blur/change).",
                                              flush=True)

                                except Exception as e:
                                    print(f"[ERROR] No se pudo escribir autoNumDocu -> {e}", flush=True)

                                # Verificar valor REAL despu√©s de escribir
                                await asyncio.sleep(0.5)
                                valor_despues = await leer_auto_doc()
                                print(f"[DEBUG] Valor autoNumDocu despu√©s de escribir: '{valor_despues}'", flush=True)

                                if valor_despues == doc_cfg:
                                    print("[OK] autoNumDocu qued√≥ correctamente con el valor de CONFIG.", flush=True)
                                    ok_doc = True
                                    break
                                else:
                                    print("[WARN] autoNumDocu a√∫n no coincide, reintentando‚Ä¶", flush=True)
                                    await asyncio.sleep(0.5)

                            if not ok_doc:
                                print(
                                    f"[ERROR] autoNumDocu NO qued√≥ en '{doc_cfg}' tras {max_intentos_doc} intentos.",
                                    flush=True,
                                )

                    # ------------------------------------------------
                    # FUNCI√ìN: un solo intento de fijar autoTipoDoc
                    # ------------------------------------------------
                    async def intentar_fijar_auto_tdoc() -> bool:
                        try:
                            await filtros_tab.select_option(AUTO_TDOC_SEL, AUTO_TDOC_VALUE)
                            pr("[OK] autoTipoDoc fijado v√≠a select_option(value).", "OK")
                            return True
                        except Exception as e:
                            pr(f"[WARN] select_option en autoTipoDoc fall√≥: {e}", "WARN")
                            return False

                    # ------------------------------------------------
                    # REINTENTOS + VERIFICACI√ìN REAL EN EL DOM
                    # ------------------------------------------------
                    max_intentos_auto_tdoc = 3
                    ok_final_auto_tdoc = False

                    for intento in range(1, max_intentos_auto_tdoc + 1):
                        pr(f"Intento autoTipoDoc #{intento}", "INFO")

                        ok_try = await intentar_fijar_auto_tdoc()

                        # Esperar loader RichFaces asociado al cambio
                        try:
                            await wait_for_loader(filtros_tab, timeout=12000)
                        except Exception:
                            pr("[WARN] Loader no detectado despu√©s de cambiar autoTipoDoc.", "WARN")

                        await asyncio.sleep(1)

                        # Validar valor REAL seleccionado en el DOM
                        try:
                            curr_value_auto_tdoc = await filtros_tab.eval_on_selector(
                                AUTO_TDOC_SEL,
                                "el => el ? el.value : null"
                            )
                        except Exception as e:
                            curr_value_auto_tdoc = None
                            pr(f"[ERROR] No se pudo leer autoTipoDoc: {e}", "ERROR")

                        pr(f"[DEBUG] autoTipoDoc actual value='{curr_value_auto_tdoc}'")

                        if ok_try and curr_value_auto_tdoc == AUTO_TDOC_VALUE:
                            pr(f"[OK] autoTipoDoc qued√≥ correctamente en '{AUTO_TDOC_VALUE}'.", "OK")
                            ok_final_auto_tdoc = True
                            break
                        else:
                            pr(
                                f"[WARN] autoTipoDoc NO qued√≥ en '{AUTO_TDOC_VALUE}', reintentando‚Ä¶",
                                "WARN",
                            )
                            await asyncio.sleep(1)

                    if not ok_final_auto_tdoc:
                        pr(
                            f"[ERROR] autoTipoDoc NO se pudo fijar en '{AUTO_TDOC_VALUE}' "
                            f"tras varios intentos.",
                            "ERROR",
                        )

                    # --- ESTADO CIVIL (autoCondCivil) ---
                    CIVIL_SEL = "#frmRiesgosPoliza\\:autoCondCivil"
                    civil_text = "S - SOLTERO"

                    print(f"[INFO] Intentando seleccionar estado civil '{civil_text}'", flush=True)

                    ok_civil = await select_option_by_text(
                        filtros_tab,
                        CIVIL_SEL,
                        civil_text,
                        "Estado Civil (autoCondCivil)",
                        wait_ajax_ms=1500,
                    )

                    if not ok_civil:
                        try:
                            curr_civil = await filtros_tab.eval_on_selector(CIVIL_SEL, "el => el.value")
                            print(
                                f"[WARN] No se pudo fijar estado civil '{civil_text}', valor actual='{curr_civil}'",
                                flush=True,
                            )
                        except Exception as e:
                            print(f"[ERROR] No se pudo leer valor actual de autoCondCivil -> {e}", flush=True)

                    # ============================================================
                    # OCUPACI√ìN (autoCondOcupacion) ‚Äî Blindado con reintentos
                    # ============================================================

                    OCUP_SEL = "#frmRiesgosPoliza\\:autoCondOcupacion"
                    ocup_text = "3 - PROFESIONAL INDEPENDIENTE"

                    print(f"[INFO] Intentando seleccionar ocupaci√≥n '{ocup_text}'", flush=True)

                    max_intentos_ocup = 4
                    ok_ocup = False

                    for intento in range(1, max_intentos_ocup + 1):
                        print(f"[INTENTO {intento}] Seleccionando ocupaci√≥n '{ocup_text}'‚Ä¶", flush=True)

                        try:
                            # --------------- Intento principal: select_option_by_text ----------------
                            ok = await select_option_by_text(
                                filtros_tab,
                                OCUP_SEL,
                                ocup_text,
                                "Ocupaci√≥n (autoCondOcupacion)",
                                wait_ajax_ms=1500,
                            )

                            if not ok:
                                print(
                                    "[WARN] select_option_by_text no logr√≥ fijar la ocupaci√≥n. Intentando fallback JS‚Ä¶",
                                    flush=True)

                                # --------------- Fallback JS: buscar opci√≥n cuyo texto coincida ---------------
                                try:
                                    await filtros_tab.evaluate(
                                        """
                                        (sel, targetText) => {
                                            const s = document.querySelector(sel);
                                            if (!s) return false;

                                            const t = (targetText || "").trim();
                                            let opt = null;

                                            const opts = Array.from(s.options || []);

                                            // Match exacto por texto visible
                                            opt = opts.find(o => o.text.trim() === t);

                                            // Match "startsWith" por si el valor viene en forma "3 - PROFESIONAL..."
                                            if (!opt) {
                                                opt = opts.find(o => o.text.trim().startsWith(t));
                                            }

                                            if (!opt) return false;

                                            s.value = opt.value;

                                            // Disparar eventos importantes para JSF / RichFaces
                                            const evtChange = new Event("change", { bubbles: true });
                                            const evtInput  = new Event("input",  { bubbles: true });
                                            s.dispatchEvent(evtChange);
                                            s.dispatchEvent(evtInput);

                                            if (typeof s.blur === "function") s.blur();

                                            return true;
                                        }
                                        """,
                                        OCUP_SEL,
                                        ocup_text,
                                    )
                                except Exception as e:
                                    print(f"[ERROR] Fallback JS lanz√≥ excepci√≥n -> {e}", flush=True)

                            # ----------------- Esperar loader si existe -----------------
                            try:
                                await wait_for_loader(filtros_tab, timeout=8000)
                            except Exception:
                                print("[DEBUG] Loader no detectado despu√©s de ocupaci√≥n (ok).", flush=True)

                            # Peque√±a espera extra
                            await asyncio.sleep(0.5)

                            # ----------------- Validar valor actual -----------------
                            try:
                                curr_ocup = await filtros_tab.eval_on_selector(
                                    OCUP_SEL, "el => (el.value || '').trim()"
                                )
                            except Exception as e:
                                curr_ocup = ""
                                print(f"[ERROR] No se pudo leer valor actual de autoCondOcupacion -> {e}", flush=True)

                            print(f"[DEBUG] Valor actual en ocupaci√≥n='{curr_ocup}'", flush=True)

                            # Validamos que el texto seleccionado sea el correspondiente
                            # Buscar opci√≥n con value=curr_ocup y revisar texto visible
                            try:
                                curr_ocup_text = await filtros_tab.eval_on_selector(
                                    OCUP_SEL,
                                    """
                                    el => {
                                        const opt = el.selectedOptions?.[0];
                                        return opt ? opt.text.trim() : "";
                                    }
                                    """,
                                )
                            except:
                                curr_ocup_text = ""

                            print(f"[DEBUG] Texto actual visible en ocupaci√≥n='{curr_ocup_text}'", flush=True)

                            # Si coincide, √©xito
                            if curr_ocup_text == ocup_text:
                                print("[OK] Ocupaci√≥n establecida correctamente.", flush=True)
                                ok_ocup = True
                                break
                            else:
                                print(
                                    f"[WARN] Ocupaci√≥n NO coincide a√∫n. Esperado='{ocup_text}', actual='{curr_ocup_text}'. Reintentando‚Ä¶",
                                    flush=True,
                                )
                                await asyncio.sleep(1.0)

                        except Exception as e:
                            print(f"[ERROR] Error general en intento #{intento} -> {e}", flush=True)
                            await asyncio.sleep(1.0)

                    # ---------------- Resultado final ----------------
                    if not ok_ocup:
                        print(
                            f"[ERROR] No se pudo fijar la ocupaci√≥n '{ocup_text}' tras {max_intentos_ocup} intentos.",
                            flush=True,
                        )
                        # Si deseas detener el flujo, activa:
                        # raise RuntimeError("No se logr√≥ fijar autoCondOcupacion")

                    # --- BOT√ìN "Continuar ¬ª" (frmRiesgosPoliza:validaAutos) ---
                    VALIDA_AUTOS_SEL = "#frmRiesgosPoliza\\:validaAutos"

                    print("[INFO] Intentando hacer click en boton 'Continuar ¬ª' (validaAutos)...", flush=True)

                    click_ok = False

                    try:
                        btn = filtros_tab.locator(VALIDA_AUTOS_SEL)
                        await btn.scroll_into_view_if_needed()
                        await btn.hover()
                        await asyncio.sleep(0.3)
                        await btn.click(force=True)
                        click_ok = True
                        print("[OK] Click humano forzado en validaAutos.", flush=True)
                    except Exception as e:
                        print(f"[WARN] Click humano fall√≥: {e}", flush=True)

                    if not click_ok:
                        try:
                            xpath_sel = "//*[@id='frmRiesgosPoliza:validaAutos']"
                            btn2 = filtros_tab.locator(f"xpath={xpath_sel}")
                            await btn2.scroll_into_view_if_needed()
                            await btn2.hover()
                            await asyncio.sleep(0.3)
                            await btn2.click(force=True)
                            click_ok = True
                            print("[OK] Click por XPATH en validaAutos.", flush=True)
                        except Exception as e:
                            print(f"[WARN] Click por XPATH fall√≥: {e}", flush=True)

                    if not click_ok:
                        try:
                            await filtros_tab.evaluate("""
                                () => {
                                    const el = document.querySelector("#frmRiesgosPoliza\\\\:validaAutos");
                                    if (el) el.click();
                                }
                            """)
                            click_ok = True
                            print("[OK] Click por JS (fallback nuclear) en validaAutos.", flush=True)
                        except Exception as e:
                            print(f"[ERROR] JS click fall√≥ en validaAutos: {e}", flush=True)

                    if click_ok:
                        try:
                            await wait_for_loader(filtros_tab, timeout=8000)
                            print("[INFO] Navegaci√≥n/validaci√≥n posterior a validaAutos completada.", flush=True)
                        except Exception:
                            print("[WARN] Loader timeout despu√©s de validaAutos.", flush=True)
                    else:
                        print("[ERROR] No se pudo hacer click en validaAutos despu√©s de todos los m√©todos.",
                              flush=True)

                except Exception as e:
                    print(f"[ERROR] No se pudo procesar autoPlaca / datos vehiculo -> {e}", flush=True)

                # ============================================================
                # DV RIESGO: INPUT PREVIO + SELECT CON REINTENTOS
                # ============================================================

                # 1) INPUT DE TEXTO dvRiesgo_0_24 (manda 'N' + Tab)
                DV_RIESGO_INPUT_SEL = "input#formaDatosVariables\\:dvRiesgo"

                try:
                    await filtros_tab.wait_for_selector(DV_RIESGO_INPUT_SEL, timeout=8000)
                    await filtros_tab.fill(DV_RIESGO_INPUT_SEL, "S")
                    pr("dvRiesgo (input texto) rellenado con 'S'", "INFO")

                    await filtros_tab.press(DV_RIESGO_INPUT_SEL, "Tab")
                    pr("Tab enviado en dvRiesgo (input texto)", "INFO")

                    # Esperar AJAX/loader despu√©s del cambio
                    try:
                        await wait_for_loader(filtros_tab, timeout=15000)
                        pr("Loader completado tras input dvRiesgo (texto)", "INFO")
                    except Exception:
                        pr("Loader pudo no desaparecer tras input dvRiesgo (texto)", "WARN")

                except Exception as e:
                    pr(f"No se pudo manejar dvRiesgo input previo: {e}", "WARN")

                # 2) SELECT dvRiesgo (formaDatosVariables:dvRiesgo)
                DV_RIESGO_SEL = "select#formaDatosVariables\\:dvRiesgo"
                dv_riesgo_text = (CONFIG.get("dv_riesgo_text") or "2 - STANDAR").strip()
                DV_RIESGO_VALUE = CONFIG.get("dv_riesgo_value", "2")  # por defecto value="2"

                pr(
                    f"Intentando fijar dvRiesgo a '{dv_riesgo_text}' (value='{DV_RIESGO_VALUE}')",
                    "INFO",
                )

                # Esperar a que el SELECT exista y sea visible
                try:
                    await filtros_tab.wait_for_selector(
                        DV_RIESGO_SEL,
                        state="visible",
                        timeout=15000,
                    )
                    pr("Select dvRiesgo visible en el DOM.", "INFO")
                except Exception as e:
                    pr(f"Select dvRiesgo no visible en DOM: {e}", "ERROR")
                else:
                    # Funci√≥n interna: un intento usando la MISMA l√≥gica que funciona para autoUso
                    async def intentar_fijar_dvRiesgo() -> bool:
                        ok = await select_option_by_text(
                            filtros_tab,
                            DV_RIESGO_SEL,
                            dv_riesgo_text,
                            "dvRiesgo (formaDatosVariables)",
                            wait_ajax_ms=1500,
                        )
                        return ok

                    max_intentos = 3
                    ok_final = False

                    for intento in range(1, max_intentos + 1):
                        pr(f"Intento dvRiesgo #{intento}", "INFO")

                        ok_try = await intentar_fijar_dvRiesgo()
                        await asyncio.sleep(1)

                        # Leer value y texto realmente seleccionados
                        try:
                            curr_value, curr_text = await filtros_tab.eval_on_selector(
                                DV_RIESGO_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.text : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value, curr_text = None, ""
                            pr(f"No se pudo leer estado de dvRiesgo: {e}", "ERROR")

                        pr(
                            f"Estado dvRiesgo -> value='{curr_value}', text='{curr_text}'",
                            "DEBUG",
                        )

                        # Condici√≥n de √©xito: value o texto coinciden
                        if ok_try and (
                                curr_value == DV_RIESGO_VALUE
                                or curr_text.strip().upper() == dv_riesgo_text.upper()
                        ):
                            pr("dvRiesgo qued√≥ fijado correctamente.", "OK")
                            ok_final = True
                            break
                        else:
                            pr(
                                "dvRiesgo a√∫n no coincide, reintentando‚Ä¶ "
                                f"(esperado value='{DV_RIESGO_VALUE}', text='{dv_riesgo_text}')",
                                "WARN",
                            )
                            await asyncio.sleep(1)

                    if not ok_final:
                        pr(
                            f"dvRiesgo NO se pudo fijar en '{dv_riesgo_text}' "
                            f"(value='{DV_RIESGO_VALUE}') tras {max_intentos} intentos.",
                            "ERROR",
                        )

                    DV_RIESGO_INPUT_SEL = "input#formaDatosVariables\\:dvRiesgo"

                    try:
                        await filtros_tab.wait_for_selector(DV_RIESGO_INPUT_SEL, timeout=8000)
                        await filtros_tab.fill(DV_RIESGO_INPUT_SEL, "N")
                        pr("dvRiesgo (input texto) rellenado con 'N'", "INFO")
                        # Esperar AJAX/loader despu√©s del cambio
                        try:
                            await wait_for_loader(filtros_tab, timeout=15000)
                            pr("Loader completado tras input dvRiesgo (texto)", "INFO")
                        except Exception:
                            pr("Loader pudo no desaparecer tras input dvRiesgo (texto)", "WARN")

                    except Exception as e:
                        pr(f"No se pudo manejar dvRiesgo input previo: {e}", "WARN")

                # ============================================================
                # 2) dvRiesgo_0_25  -> Asistencia familiar
                # <select name="formaDatosVariables:dvRiesgo_0_25" ...>
                # ============================================================
                DV25_SEL = "select[name='formaDatosVariables:dvRiesgo_0_25']"
                DV25_VALUE = CONFIG.get("dv_0_25_value", "1")  # '1' o '6'
                dv25_text = (CONFIG.get("dv_0_25_text") or "1 - ASISTENCIA FAMILIAR").strip()

                pr(f"Intentando fijar dvRiesgo_0_25 a '{dv25_text}' (value='{DV25_VALUE}')", "INFO")

                try:
                    ok_25 = await select_richfaces_by_human_keys(
                        filtros_tab,
                        DV25_SEL,
                        dv25_text,
                        desc="dvRiesgo_0_25"
                    )
                except Exception as e:
                    ok_25 = False
                    pr(f"Error en select_richfaces_by_human_keys(dvRiesgo_0_25): {e}", "ERROR")

                if ok_25:
                    try:
                        curr_value_25, curr_text_25 = await filtros_tab.eval_on_selector(
                            DV25_SEL,
                            """el => {
                                if (!el) return [null, ""];
                                const val = el.value || null;
                                const opt = el.options[el.selectedIndex] || null;
                                const txt = opt ? opt.textContent.trim() : "";
                                return [val, txt];
                            }"""
                        )
                    except Exception as e:
                        curr_value_25, curr_text_25 = None, ""
                        pr(f"No se pudo leer estado final de dvRiesgo_0_25: {e}", "ERROR")

                    pr(
                        f"Estado final dvRiesgo_0_25 -> value='{curr_value_25}', text='{curr_text_25}'",
                        "DEBUG",
                    )
                else:
                    pr("No se pudo fijar dvRiesgo_0_25 mediante selecci√≥n humana.", "ERROR")

                # ============================================================
                # 3) dvRiesgo_0_27  -> S / N
                # <select name="formaDatosVariables:dvRiesgo_0_27" ...>
                # ============================================================
                DV27_SEL = "select[name='formaDatosVariables:dvRiesgo_0_27']"
                DV27_VALUE = CONFIG.get("dv_0_27_value", "N")
                dv27_text = (CONFIG.get("dv_0_27_text") or "N - No").strip()

                pr(f"Intentando fijar dvRiesgo_0_27 a '{dv27_text}' (value='{DV27_VALUE}')", "INFO")

                try:
                    ok_27 = await select_richfaces_by_human_keys(
                        filtros_tab,
                        DV27_SEL,
                        dv27_text,
                        desc="dvRiesgo_0_27"
                    )
                except Exception as e:
                    ok_27 = False
                    pr(f"Error en select_richfaces_by_human_keys(dvRiesgo_0_27): {e}", "ERROR")

                if ok_27:
                    try:
                        curr_value_27, curr_text_27 = await filtros_tab.eval_on_selector(
                            DV27_SEL,
                            """el => {
                                if (!el) return [null, ""];
                                const val = el.value || null;
                                const opt = el.options[el.selectedIndex] || null;
                                const txt = opt ? opt.textContent.trim() : "";
                                return [val, txt];
                            }"""
                        )
                    except Exception as e:
                        curr_value_27, curr_text_27 = None, ""
                        pr(f"No se pudo leer estado final de dvRiesgo_0_27: {e}", "ERROR")

                    pr(
                        f"Estado final dvRiesgo_0_27 -> value='{curr_value_27}', text='{curr_text_27}'",
                        "DEBUG",
                    )
                else:
                    pr("No se pudo fijar dvRiesgo_0_27 mediante selecci√≥n humana.", "ERROR")

                # ============================================================
                # 5) dvRiesgo_0_24  -> INPUT TEXTO (ej: 'N')
                # <input type="text" name="formaDatosVariables:dvRiesgo_0_24" ...>
                # ============================================================
                DV24_INPUT_SEL = "input[name='formaDatosVariables:dvRiesgo_0_24']"
                dv24_value = CONFIG.get("dv_0_24_value", "S")

                pr(f"Llenando dvRiesgo_0_24 con '{dv24_value}'", "INFO")
                try:
                    await filtros_tab.wait_for_selector(DV24_INPUT_SEL, timeout=15000)
                    await filtros_tab.fill(DV24_INPUT_SEL, dv24_value)
                    pr("dvRiesgo_0_24 rellenado.", "INFO")

                    # Disparar onchange (Tab) y esperar loader
                    try:
                        await filtros_tab.press(DV24_INPUT_SEL, "900485169")
                        await filtros_tab.press(DV24_INPUT_SEL, "Tab")
                        pr("Tab enviado en dvRiesgo_0_24.", "INFO")
                    except Exception:
                        pr("No se pudo enviar Tab en dvRiesgo_0_24 (se contin√∫a).", "WARN")

                    try:
                        await wait_for_loader(filtros_tab, timeout=15000)
                        pr("Loader posterior a dvRiesgo_0_24 completado.", "INFO")
                    except Exception:
                        pr("Loader no se detect√≥ o tard√≥ tras dvRiesgo_0_24.", "WARN")

                except Exception as e:
                    pr(f"No se pudo manejar dvRiesgo_0_24 -> {e}", "ERROR")

                # ============================================================
                # 7) dvRiesgo_0_26  -> SELECT S / N (Vinculaciones)
                # <select name="formaDatosVariables:dvRiesgo_0_26" ...>
                # ============================================================
                DV26_SEL = "select[name='formaDatosVariables:dvRiesgo_0_26']"
                DV26_VALUE = CONFIG.get("dv_0_26_value", "N")  # por defecto 'N'
                dv26_text = (CONFIG.get("dv_0_26_text") or "N - No").strip()

                pr(f"Intentando fijar dvRiesgo_0_26 a '{dv26_text}' (value='{DV26_VALUE}')", "INFO")

                try:
                    await filtros_tab.wait_for_selector(DV26_SEL, timeout=15000)
                    pr("Select dvRiesgo_0_26 presente en DOM.", "INFO")
                except Exception as e:
                    pr(f"Select dvRiesgo_0_26 NO visible/presente: {e}", "ERROR")
                else:

                    async def intentar_fijar_dvRiesgo_0_26() -> bool:
                        """
                        Un intento de fijar dvRiesgo_0_26:
                        1) CLICK para disparar onfocus (campoOculto_dvRiesgo='0_26')
                        2) Seleccionar por TEXTO (select_option_by_text)
                        3) Tab para onchange
                        4) Esperar loader
                        """
                        # 1) Focus / click humano
                        try:
                            loc = filtros_tab.locator(DV26_SEL)
                            await loc.scroll_into_view_if_needed()
                            await loc.click()
                            pr("Click/focus en dvRiesgo_0_26 (onfocus ejecutado).", "DEBUG")
                            await asyncio.sleep(0.2)
                        except Exception as e:
                            pr(f"No se pudo hacer click inicial en dvRiesgo_0_26: {e}", "WARN")

                        # 2) Selecci√≥n por texto
                        ok = await select_option_by_text(
                            filtros_tab,
                            DV26_SEL,
                            dv26_text,
                            "dvRiesgo_0_26 (S/N)",
                            wait_ajax_ms=1200,
                        )

                        # 3) Tab para disparar onchange
                        if ok:
                            try:
                                await filtros_tab.press(DV26_SEL, "Tab")
                                pr("Tab enviado en dvRiesgo_0_26.", "DEBUG")
                            except Exception as e:
                                pr(f"No se pudo enviar Tab en dvRiesgo_0_26: {e}", "WARN")

                        # 4) Esperar AJAX/loader despu√©s del cambio
                        try:
                            await wait_for_loader(filtros_tab, timeout=15000)
                            pr("Loader posterior a dvRiesgo_0_26 completado.", "INFO")
                        except Exception:
                            pr("Loader no detectado tras dvRiesgo_0_26 (continuando).", "WARN")

                        return ok

                    max_intentos_26 = 3
                    ok_final_26 = False

                    for intento in range(1, max_intentos_26 + 1):
                        pr(f"Intento dvRiesgo_0_26 #{intento}", "INFO")

                        ok_try = await intentar_fijar_dvRiesgo_0_26()
                        await asyncio.sleep(1)

                        # Releer valor REAL del DOM (por si JSF re-pint√≥)
                        try:
                            curr_value_26, curr_text_26 = await filtros_tab.eval_on_selector(
                                DV26_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.text : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value_26, curr_text_26 = None, ""
                            pr(f"No se pudo leer estado de dvRiesgo_0_26: {e}", "ERROR")

                        pr(
                            f"Estado dvRiesgo_0_26 -> value='{curr_value_26}', text='{curr_text_26}'",
                            "DEBUG",
                        )

                        # Condici√≥n de √©xito: que quede realmente N - No (o lo que definas en CONFIG)
                        if ok_try and (
                                curr_value_26 == DV26_VALUE
                                or curr_text_26.strip().upper() == dv26_text.upper()
                        ):
                            pr("dvRiesgo_0_26 qued√≥ fijado correctamente.", "OK")
                            ok_final_26 = True
                            break
                        else:
                            pr(
                                "dvRiesgo_0_26 NO coincide a√∫n, reintentando‚Ä¶ "
                                f"(esperado value='{DV26_VALUE}', text='{dv26_text}')",
                                "WARN",
                            )
                            await asyncio.sleep(1)

                    if not ok_final_26:
                        pr(
                            f"dvRiesgo_0_26 NO se pudo fijar en '{dv26_text}' "
                            f"(value='{DV26_VALUE}') tras {max_intentos_26} intentos.",
                            "ERROR",
                        )

                curr_value_26, curr_text_26 = None, ""

                # ============================================================
                # 1) dvRiesgo_0_34 (S / N)  -> name='formaDatosVariables:dvRiesgo_0_34'
                #    L√≥gica:
                #       - Si BENEFICIARIO ONEROSO est√° vac√≠o ‚Üí dvRiesgo_0_34 = 'N'
                #       - Si BENEFICIARIO ONEROSO tiene valor ‚Üí dvRiesgo_0_34 = 'S'
                # ============================================================

                DV34_SEL = "select[name='formaDatosVariables:dvRiesgo_0_34']"

                benef_oneroso = (CONFIG.get("BENEFICIARIO ONEROSO") or "").strip()

                if benef_oneroso:
                    DV34_VALUE = "S"
                    dv34_text = (CONFIG.get("dv_0_34_text") or "S - Si").strip()
                    pr(f"BENEFICIARIO ONEROSO='{benef_oneroso}' ‚Üí dvRiesgo_0_34 debe ser 'S'.", "INFO")
                else:
                    DV34_VALUE = "N"
                    dv34_text = (CONFIG.get("dv_0_34_text_no") or "N - No").strip()
                    pr("BENEFICIARIO ONEROSO vac√≠o ‚Üí dvRiesgo_0_34 debe ser 'N'.", "INFO")

                pr(f"Intentando fijar dvRiesgo_0_34 a '{dv34_text}' (value objetivo='{DV34_VALUE}')", "INFO")

                dv34_es_si = False
                curr_value_34, curr_text_34 = None, ""

                # ------------------------------------------------------------
                # Helper: forzar dvRiesgo_0_34 a "S" cuando hay beneficiario
                # ------------------------------------------------------------
                async def forzar_dv34_en_S() -> bool:
                    """
                    Intenta varias veces dejar dvRiesgo_0_34 en 'S' usando
                    select_richfaces_by_human_keys y validando value/texto.
                    """
                    max_intentos_34 = 3
                    objetivo_text = (CONFIG.get("dv_0_34_text") or "S - Si").strip()

                    for intento in range(1, max_intentos_34 + 1):
                        pr(f"[FORZAR] Intento #{intento} para dejar dvRiesgo_0_34 = 'S'‚Ä¶", "INFO")
                        try:
                            await filtros_tab.wait_for_selector(DV34_SEL, state="visible", timeout=8000)
                        except Exception as e:
                            pr(f"[FORZAR][ERROR] dvRiesgo_0_34 no visible: {e}", "ERROR")
                            return False

                        try:
                            ok = await select_richfaces_by_human_keys(
                                filtros_tab,
                                DV34_SEL,
                                objetivo_text,
                                desc="dvRiesgo_0_34 (forzar S)",
                            )
                        except Exception as e:
                            ok = False
                            pr(f"[FORZAR] Error en select_richfaces_by_human_keys(dvRiesgo_0_34): {e}", "ERROR")

                        # Leer estado real
                        try:
                            val, txt = await filtros_tab.eval_on_selector(
                                DV34_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.textContent.trim() : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            val, txt = None, ""
                            pr(f"[FORZAR] No se pudo leer estado final de dvRiesgo_0_34: {e}", "ERROR")

                        pr(f"[FORZAR][DEBUG] dvRiesgo_0_34 -> value='{val}', text='{txt}'", "DEBUG")

                        es_S = (val == "S") or (txt or "").strip().upper().startswith("S -")

                        if ok and es_S:
                            pr("[FORZAR][OK] dvRiesgo_0_34 qued√≥ forzado en 'S'.", "OK")
                            return True
                        else:
                            pr("[FORZAR][WARN] dvRiesgo_0_34 a√∫n NO es 'S', reintentando‚Ä¶", "WARN")
                            await asyncio.sleep(1.0)

                    pr("[FORZAR][ERROR] No se logr√≥ fijar dvRiesgo_0_34 en 'S' despu√©s de varios intentos.", "ERROR")
                    return False

                # ============================================================
                # Selecci√≥n inicial de dvRiesgo_0_34 seg√∫n haya o no beneficiario
                # ============================================================

                try:
                    await filtros_tab.wait_for_selector(DV34_SEL, timeout=15000)
                except Exception as e:
                    pr(f"[ERROR] dvRiesgo_0_34 no visible en DOM: {e}", "ERROR")
                else:
                    try:
                        ok_34 = await select_richfaces_by_human_keys(
                            filtros_tab,
                            DV34_SEL,
                            dv34_text,
                            desc="dvRiesgo_0_34",
                        )
                    except Exception as e:
                        ok_34 = False
                        pr(f"Error en select_richfaces_by_human_keys(dvRiesgo_0_34): {e}", "ERROR")

                    if ok_34:
                        # Leer el value/texto reales que quedaron en el DOM
                        try:
                            curr_value_34, curr_text_34 = await filtros_tab.eval_on_selector(
                                DV34_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.textContent.trim() : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value_34, curr_text_34 = None, ""
                            pr(f"No se pudo leer estado final de dvRiesgo_0_34: {e}", "ERROR")

                        pr(
                            f"Estado final dvRiesgo_0_34 -> value='{curr_value_34}', text='{curr_text_34}'",
                            "DEBUG",
                        )

                        dv34_es_si = (
                                (curr_value_34 == "S")
                                or (curr_text_34 or "").strip().upper().startswith("S -")
                        )

                        if dv34_es_si:
                            pr("dvRiesgo_0_34 qued√≥ como 'S'.", "OK")
                        else:
                            pr("dvRiesgo_0_34 qued√≥ distinto de 'S'.", "INFO")
                    else:
                        pr("No se pudo fijar dvRiesgo_0_34 mediante selecci√≥n humana.", "ERROR")

                # ============================================================
                # Ajuste extra: si HAY BENEFICIARIO y dvRiesgo_0_34 NO est√° en 'S',
                # intentar forzarlo nuevamente a 'S' antes de llenar datos.
                # ============================================================

                if benef_oneroso and not dv34_es_si:
                    pr("Hay BENEFICIARIO ONEROSO pero dvRiesgo_0_34 no es 'S' ‚Üí forzando a 'S'‚Ä¶", "WARN")
                    dv34_forzado = await forzar_dv34_en_S()
                    dv34_es_si = dv34_forzado

                # ============================================================
                # 2) Si dvRiesgo_0_34 ES "S" y BENEFICIARIO ONEROSO NO est√° vac√≠o:
                #    - Llenar dvRiesgo_0_32 con el n√∫mero de beneficiario oneroso
                #    - Seleccionar dvRiesgo_0_31 con el tipo de documento (ej: 'NT')
                # ============================================================

                if dv34_es_si and benef_oneroso:
                    # ---------- dvRiesgo_0_32 (N√∫mero de documento del beneficiario oneroso) ----------
                    INPUT32_SEL = "input[name='formaDatosVariables:dvRiesgo_0_32']"
                    dv32_value = benef_oneroso  # directamente desde CONFIG

                    pr(
                        f"dvRiesgo_0_34 es 'S' ‚Üí llenando dvRiesgo_0_32 con '{dv32_value}'",
                        "INFO",
                    )
                    try:
                        await filtros_tab.wait_for_selector(INPUT32_SEL, timeout=15000)
                        await filtros_tab.fill(INPUT32_SEL, dv32_value)
                        pr("dvRiesgo_0_32 rellenado.", "INFO")

                        # Tab para disparar onchange + posible loader
                        try:
                            await filtros_tab.press(INPUT32_SEL, "Tab")
                            pr("Tab enviado en dvRiesgo_0_32.", "INFO")
                        except Exception:
                            pass

                        try:
                            await wait_for_loader(filtros_tab, timeout=15000)
                            pr("Loader posterior a dvRiesgo_0_32 completado.", "INFO")
                        except Exception:
                            pr("Loader no se detect√≥ o tard√≥ demasiado tras dvRiesgo_0_32.", "WARN")

                    except Exception as e:
                        pr(f"No se pudo llenar dvRiesgo_0_32 -> {e}", "ERROR")

                    # ---------- dvRiesgo_0_31 (Tipo documento beneficiario oneroso) ----------
                    DV31_VALUE = (CONFIG.get("BENEFICIARIO_TIPO_DOC") or "NT").strip()
                    DV31_SELECTORS = [
                        "select[name='formaDatosVariables:dvRiesgo_0_31']",
                        "#formaDatosVariables\\:dvRiesgo",
                        "xpath=//select[@name='formaDatosVariables:dvRiesgo_0_31']",
                        "xpath=//select[contains(@name, 'dvRiesgo_0_31')]",
                    ]

                    max_intentos_dv31 = 3
                    pr(f"Intentando seleccionar dvRiesgo_0_31 = '{DV31_VALUE}' (tipo doc beneficiario)‚Ä¶", "INFO")

                    async def seleccionar_dv31_una_vez() -> bool:
                        ok = False

                        # 1) Intento normal de selecci√≥n (click + select_option)
                        for sel in DV31_SELECTORS:
                            try:
                                await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                                combo = filtros_tab.locator(sel)

                                await combo.scroll_into_view_if_needed()
                                await combo.click()
                                await asyncio.sleep(0.2)

                                await combo.select_option(DV31_VALUE)
                                pr(f"[OK] dvRiesgo_0_31 seleccionado como '{DV31_VALUE}' usando '{sel}'.", "OK")

                                # enviar Tab para disparar el onchange ‚Üí RichFaces.ajax
                                try:
                                    await filtros_tab.press(sel, "Tab")
                                    pr("Tab enviado despu√©s de seleccionar dvRiesgo_0_31.", "INFO")
                                except Exception as e:
                                    pr(f"[WARN] No se pudo enviar Tab en dvRiesgo_0_31: {e}", "WARN")

                                ok = True
                                break

                            except Exception as e:
                                pr(f"[WARN] Fall√≥ selecci√≥n dvRiesgo_0_31 con '{sel}': {e}", "WARN")

                        # 2) Fallback JS si fall√≥ todo lo anterior
                        if not ok:
                            try:
                                js_ok = await filtros_tab.evaluate(
                                    """
                                    (value) => {
                                        const selects = Array.from(document.querySelectorAll("select"));
                                        const el = selects.find(s => (s.name || "").includes("dvRiesgo_0_31"));
                                        if (!el) return false;

                                        el.value = value;

                                        el.dispatchEvent(new Event('change', { bubbles: true }));
                                        el.dispatchEvent(new Event('input',  { bubbles: true }));

                                        if (typeof el.blur === 'function') el.blur();

                                        return true;
                                    }
                                    """,
                                    DV31_VALUE,
                                )
                                if js_ok:
                                    pr("[OK] dvRiesgo_0_31 seleccionado v√≠a JS directo.", "OK")
                                    ok = True
                                else:
                                    pr("[WARN] JS no pudo seleccionar dvRiesgo_0_31.", "WARN")

                            except Exception as e:
                                pr(f"[ERROR] Fallback JS dvRiesgo_0_31 fall√≥: {e}", "ERROR")

                        # 3) loader RichFaces
                        try:
                            await wait_for_loader(filtros_tab, timeout=15000)
                            pr("Loader tras dvRiesgo_0_31 completado.", "INFO")
                        except Exception:
                            pr("No se detect√≥ loader tras dvRiesgo_0_31 (ok).", "WARN")

                        return ok

                    # REINTENTOS Y VALIDACI√ìN FINAL
                    for intento in range(1, max_intentos_dv31 + 1):
                        pr(f"Intento #{intento} para seleccionar dvRiesgo_0_31...", "INFO")

                        _ = await seleccionar_dv31_una_vez()
                        await asyncio.sleep(0.5)

                        # Verificar valor real seleccionado
                        try:
                            valor_actual = await filtros_tab.evaluate(
                                """
                                () => {
                                    const select = Array.from(document.querySelectorAll("select"))
                                        .find(s => (s.name || "").includes("dvRiesgo_0_31"));
                                    if (!select) return null;
                                    return select.value;
                                }
                                """
                            )
                        except Exception as e:
                            valor_actual = None
                            pr(f"[ERROR] No se pudo leer el valor actual dvRiesgo_0_31: {e}", "ERROR")

                        pr(f"[DEBUG] dvRiesgo_0_31 actual = '{valor_actual}' (esperado='{DV31_VALUE}')", "DEBUG")

                        if valor_actual == DV31_VALUE:
                            pr("[OK] Confirmado: dvRiesgo_0_31 qued√≥ correctamente en el tipo doc del beneficiario.",
                               "OK")
                            break
                        else:
                            pr("[WARN] dvRiesgo_0_31 NO coincide (reintentando).", "WARN")
                            await asyncio.sleep(1.0)
                    else:
                        pr("[ERROR] No se pudo dejar dvRiesgo_0_31 en el valor esperado despu√©s de varios intentos.",
                           "ERROR")

                else:
                    # Si NO es 'S' o no hay beneficiario, no llenamos nada
                    if not benef_oneroso:
                        pr("BENEFICIARIO ONEROSO vac√≠o ‚Üí no se llenan dvRiesgo_0_32 ni dvRiesgo_0_31.", "INFO")
                    else:
                        pr("dvRiesgo_0_34 no est√° en 'S' ‚Üí se omite llenado de datos de beneficiario.", "WARN")

                # ============================================================
                # 8) CLICK en pesta√±a "CONTRATACION DE COBERTURAS"
                # <span ...>CONTRATACION DE COBERTURAS</span>
                # ============================================================

                # ============================================================
                # dvRiesgo_0_45  ‚Üí Debe quedar en "S" (con autocorrecci√≥n)
                # ============================================================

                DV45_VALUE = "S"
                DV45_TEXT = "S - Si"

                DV45_SELECTORS = [
                    "select[name='formaDatosVariables:dvRiesgo_0_45']",
                    "#formaDatosVariables\\:dvRiesgo",
                    "xpath=//select[@name='formaDatosVariables:dvRiesgo_0_45']",
                    "xpath=//select[contains(@name,'dvRiesgo_0_45')]",
                ]

                MAX_INTENTOS_DV45 = 3

                pr("=== Seleccionando dvRiesgo_0_45 = 'S' ===", "INFO")

                async def seleccionar_dv45_una_vez() -> bool:
                    """
                    Un solo intento de dejar dvRiesgo_0_45 en 'S'.
                    Usa select_option primero y luego fallback JS.
                    """
                    ok = False

                    # --------------------------------------------------------
                    # 1) Intento normal (click + select_option)
                    # --------------------------------------------------------
                    for sel in DV45_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, state="visible", timeout=6000)
                            combo = filtros_tab.locator(sel)

                            await combo.scroll_into_view_if_needed()
                            await combo.click()
                            await asyncio.sleep(0.2)

                            await combo.select_option(DV45_VALUE)
                            pr(f"[OK] dvRiesgo_0_45 seleccionado como 'S' usando selector '{sel}'.", "OK")

                            try:
                                await filtros_tab.press(sel, "Tab")
                            except Exception as e:
                                pr(f"[WARN] No se pudo enviar Tab en dvRiesgo_0_45: {e}", "WARN")

                            ok = True
                            break

                        except Exception as e:
                            pr(f"[WARN] Fall√≥ selecci√≥n dvRiesgo_0_45 con '{sel}': {e}", "WARN")

                    # --------------------------------------------------------
                    # 2) Fallback JavaScript (√∫ltima opci√≥n)
                    # --------------------------------------------------------
                    if not ok:
                        try:
                            js_ok = await filtros_tab.evaluate(
                                """
                                (value) => {
                                    const el = Array.from(document.querySelectorAll("select"))
                                        .find(s => (s.name || "").includes("dvRiesgo_0_45"));
                                    if (!el) return false;

                                    el.value = value;
                                    el.dispatchEvent(new Event('change', { bubbles: true }));
                                    el.dispatchEvent(new Event('input',  { bubbles: true }));
                                    if (typeof el.blur === 'function') el.blur();

                                    return true;
                                }
                                """,
                                DV45_VALUE,
                            )

                            if js_ok:
                                pr("[OK] dvRiesgo_0_45 fijado por JS directo.", "OK")
                                ok = True
                            else:
                                pr("[WARN] JS NO pudo seleccionar dvRiesgo_0_45.", "WARN")

                        except Exception as e:
                            pr(f"[ERROR] JS fallback dvRiesgo_0_45 fall√≥: {e}", "ERROR")

                    # --------------------------------------------------------
                    # 3) Esperar loader RichFaces
                    # --------------------------------------------------------
                    try:
                        await wait_for_loader(filtros_tab, timeout=15000)
                        pr("Loader tras dvRiesgo_0_45 completado (o timeout manejado).", "INFO")
                    except Exception:
                        pr("[WARN] Loader tras dvRiesgo_0_45 no detectado claramente (continuo).", "WARN")

                    return ok

                async def leer_valor_dv45() -> str | None:
                    """
                    Lee el value REAL del select dvRiesgo_0_45 desde el DOM.
                    """
                    try:
                        valor_actual = await filtros_tab.evaluate(
                            """
                            () => {
                                const el = Array.from(document.querySelectorAll("select"))
                                    .find(s => (s.name || "").includes("dvRiesgo_0_45"));
                                return el ? el.value : null;
                            }
                            """
                        )
                        return valor_actual
                    except Exception as e:
                        pr(f"[ERROR] No se pudo leer valor actual dvRiesgo_0_45: {e}", "ERROR")
                        return None

                # ============================================================
                # REINTENTOS INICIALES + VALIDACI√ìN
                # ============================================================

                for intento in range(1, MAX_INTENTOS_DV45 + 1):
                    pr(f"Intento dvRiesgo_0_45 #{intento}", "INFO")

                    _ = await seleccionar_dv45_una_vez()
                    await asyncio.sleep(0.5)

                    valor_actual = await leer_valor_dv45()
                    pr(f"[DEBUG] dvRiesgo_0_45 actual = '{valor_actual}' (esperado='S')", "DEBUG")

                    if valor_actual == DV45_VALUE:
                        pr("[OK] Confirmado: dvRiesgo_0_45 qued√≥ correctamente en 'S' tras selecci√≥n inicial.", "OK")
                        break
                    else:
                        pr("[WARN] dvRiesgo_0_45 NO coincide a√∫n (reintentando).", "WARN")
                        await asyncio.sleep(1.0)

                else:
                    pr("[ERROR] NO se pudo fijar dvRiesgo_0_45 en 'S' despu√©s de varios intentos.", "ERROR")

                # ============================================================
                # HELPER: asegurar que dvRiesgo_0_45 se MANTENGA en "S"
                # Revisa varias veces despu√©s (por si alg√∫n AJAX lo cambia a "N")
                # ============================================================

                async def asegurar_dv45_estable(
                        revisiones: int = 5,
                        delay_s: float = 2.0,
                ) -> None:
                    """
                    Revisa varias veces el valor de dvRiesgo_0_45.
                    Si en alg√∫n punto NO est√° en 'S', lo corrige de nuevo.
                    √ötil cuando hay loaders/AJAX que reescriben el valor.
                    """
                    for ronda in range(1, revisiones + 1):
                        valor_actual = await leer_valor_dv45()
                        pr(
                            f"[CHECK ronda {ronda}] dvRiesgo_0_45 = '{valor_actual}' (esperado='S')",
                            "DEBUG",
                        )

                        if valor_actual != DV45_VALUE:
                            pr(
                                f"[WARN] dvRiesgo_0_45 cambi√≥ a '{valor_actual}' en la ronda {ronda}, "
                                f"reaplicando selecci√≥n 'S'...",
                                "WARN",
                            )
                            _ = await seleccionar_dv45_una_vez()
                        else:
                            pr("[OK] dvRiesgo_0_45 sigue en 'S' en esta ronda.", "OK")

                        # Peque√±a espera antes de la siguiente revisi√≥n
                        await asyncio.sleep(delay_s)

                # ============================================================
                # LLAMADA FINAL AL HELPER DE ESTABILIDAD
                # (Puedes mover esto m√°s adelante si quieres revisar despu√©s
                #  de otros loaders / pasos)
                # ============================================================

                await asegurar_dv45_estable(revisiones=5, delay_s=2.0)

                a = input("hola")
                TAB_CONT_SEL = "span[tabindex='2000']"

                pr("Intentando hacer click en pesta√±a 'CONTRATACION DE COBERTURAS'...", "INFO")

                click_ok = False
                try:
                    await filtros_tab.wait_for_selector(TAB_CONT_SEL, timeout=15000)
                    loc = filtros_tab.locator(TAB_CONT_SEL)
                    await loc.scroll_into_view_if_needed()
                    await loc.hover()
                    await asyncio.sleep(0.3)
                    await loc.click(force=True)
                    click_ok = True
                    pr("[OK] Click en pesta√±a 'CONTRATACION DE COBERTURAS'.", "INFO")
                except Exception as e:
                    pr(f"[WARN] Fall√≥ click normal en pesta√±a: {e}", "WARN")

                # FallBack: click v√≠a JS
                if not click_ok:
                    try:
                        await filtros_tab.evaluate(
                            """document.querySelector("span[tabindex='2000']").click();"""
                        )
                        click_ok = True
                        pr("[OK] Click JS en pesta√±a 'CONTRATACION DE COBERTURAS'.", "INFO")
                    except Exception as e:
                        pr(f"[ERROR] No se pudo hacer click en pesta√±a por ning√∫n m√©todo: {e}", "ERROR")

                # Esperar carga del panel
                try:
                    await wait_for_loader(filtros_tab, timeout=15000)
                    pr("Loader tras abrir pesta√±a 'CONTRATACION DE COBERTURAS' completado.", "INFO")
                except Exception:
                    pr("Loader no detectado tras apertura de pesta√±a (continuando).", "WARN")

                # ============================================================
                # 9) Click en bot√≥n "Continuar ¬ª" de Datos Variables de Riesgo
                # <input id="formaDatosVariables:validaDatosVariablesRiesgo" ...>
                # ============================================================
                BTN_DV_CONT_SEL = "#formaDatosVariables\\:validaDatosVariablesRiesgo"

                pr("Intentando hacer click en bot√≥n 'Continuar ¬ª' (validaDatosVariablesRiesgo)...", "INFO")

                click_ok = False

                # 1) Intento normal estilo humano
                try:
                    await filtros_tab.wait_for_selector(BTN_DV_CONT_SEL, timeout=15000)
                    btn = filtros_tab.locator(BTN_DV_CONT_SEL)
                    await btn.scroll_into_view_if_needed()
                    await btn.hover()
                    await asyncio.sleep(0.3)
                    await btn.click(force=True)
                    click_ok = True
                    pr("[OK] Click humano en validaDatosVariablesRiesgo.", "INFO")
                except Exception as e:
                    pr(f"[WARN] Click humano fall√≥ en validaDatosVariablesRiesgo: {e}", "WARN")

                # 2) Fallback por XPATH si falla el CSS
                if not click_ok:
                    try:
                        xpath_sel = "//*[@id='formaDatosVariables:validaDatosVariablesRiesgo']"
                        btn2 = filtros_tab.locator(f"xpath={xpath_sel}")
                        await btn2.scroll_into_view_if_needed()
                        await btn2.hover()
                        await asyncio.sleep(0.3)
                        await btn2.click(force=True)
                        click_ok = True
                        pr("[OK] Click por XPATH en validaDatosVariablesRiesgo.", "INFO")
                    except Exception as e:
                        pr(f"[WARN] Click por XPATH fall√≥ en validaDatosVariablesRiesgo: {e}", "WARN")

                # 3) Fallback nuclear: click por JS directo
                if not click_ok:
                    try:
                        await filtros_tab.evaluate(
                            """
                            () => {
                                const el = document.getElementById('formaDatosVariables:validaDatosVariablesRiesgo');
                                if (el) el.click();
                            }
                            """
                        )
                        click_ok = True
                        pr("[OK] Click JS (fallback nuclear) en validaDatosVariablesRiesgo.", "INFO")
                    except Exception as e:
                        pr(f"[ERROR] JS click fall√≥ en validaDatosVariablesRiesgo: {e}", "ERROR")

                # 4) Esperar loader / AJAX despu√©s del click
                if click_ok:
                    try:
                        await wait_for_loader(filtros_tab, timeout=20000)
                        pr("Loader posterior a validaDatosVariablesRiesgo completado.", "INFO")
                    except Exception:
                        pr("Loader no se detect√≥ o tard√≥ demasiado tras validaDatosVariablesRiesgo.", "WARN")
                else:
                    pr("[ERROR] No se pudo hacer click en validaDatosVariablesRiesgo con ning√∫n m√©todo.", "ERROR")

                # ============================================================
                # 10) Click en bot√≥n EDITAR (fila 0) -> btnMuestraDV
                #    <input id="formaCoberturas:table:0:btnMuestraDV" ... type="image">
                #    Abre el panel flotante de Datos Variables Cobertura
                # ============================================================

                POPUP_DV_SEL = "#formaDV\\:popupDVCoberturas_container"
                POPUP_HDR_SEL = "#formaDV\\:mensajeDV"
                DV_COB_SELECT_SEL = "#formaDV\\:dvCoberturasPoliza"

                # Selectores para el bot√≥n EDITAR (fila 0) lo m√°s gen√©ricos posible
                EDIT_SELECTORS = [
                    "#formaCoberturas\\:table\\:0\\:btnMuestraDV",  # ID t√≠pico
                    "input[name='formaCoberturas:table:0:btnMuestraDV']",  # name t√≠pico
                    "input[type='image'][name='formaCoberturas:table:0:btnMuestraDV']",  # type=image + name
                    "xpath=//input[contains(@name,'formaCoberturas:table:0:btnMuestraDV')]",  # xpath espec√≠fico
                    # Fallback m√°s gen√©rico: cualquier edit.gif en la primera fila de la tabla
                    "xpath=//table[@id='formaCoberturas:table']//tr[1]//input[contains(@src,'edit.gif')]",
                    # √öltimo recurso: cualquier image input con edit.gif en la tabla de coberturas
                    "xpath=//table[@id='formaCoberturas:table']//input[@type='image' and contains(@src,'edit.gif')]",
                ]

                pr("Intentando abrir panel de Datos Variables Cobertura (btnMuestraDV)...", "INFO")

                async def click_btn_muestra_dv_once() -> bool:
                    """
                    Un solo intento de disparar el bot√≥n EDITAR (btnMuestraDV)
                    usando varios m√©todos de click. Devuelve True si cree que
                    lanz√≥ el evento, False si todo fall√≥.
                    """
                    ok = False

                    # 1) Intento tipo "click humano" sobre varios selectores
                    for sel in EDIT_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                            btn = filtros_tab.locator(sel)
                            await btn.scroll_into_view_if_needed()
                            await btn.hover()
                            await asyncio.sleep(0.3)

                            # Click normal
                            await btn.click(force=True)
                            pr(f"[OK] Click humano en btnMuestraDV con selector '{sel}'.", "OK")
                            ok = True

                            # Peque√±a pausa y segundo click suave (simular doble click / insistencia)
                            await asyncio.sleep(0.2)
                            try:
                                await btn.click(force=True)
                                pr(f"[INFO] Segundo click (doble intento) en btnMuestraDV con '{sel}'.", "INFO")
                            except Exception:
                                # Si el segundo falla no es grave, el primero ya se ejecut√≥
                                pass

                            break
                        except Exception as e:
                            pr(f"[WARN] Click humano fall√≥ en btnMuestraDV con '{sel}': {e}", "WARN")

                    # 2) Fallback JS: buscar din√°micamente el bot√≥n en la tabla y disparar click
                    if not ok:
                        try:
                            res = await filtros_tab.evaluate(
                                """
                                () => {
                                    // Buscar primero en la tabla de coberturas
                                    const table = document.getElementById('formaCoberturas:table');
                                    let btn = null;

                                    if (table) {
                                        // 1) Por name que contenga 'btnMuestraDV'
                                        btn = table.querySelector("input[name*='btnMuestraDV'][type='image']")
                                              || table.querySelector("input[type='image'][src*='edit.gif']");
                                    }

                                    // Si no lo encontramos en la tabla, buscar global como √∫ltimo recurso
                                    if (!btn) {
                                        btn = document.querySelector("input[name*='btnMuestraDV'][type='image']")
                                           || document.querySelector("input[type='image'][src*='edit.gif']");
                                    }

                                    if (!btn) return false;

                                    const ev = new MouseEvent('click', {
                                        bubbles: true,
                                        cancelable: true,
                                        view: window
                                    });

                                    // Primer intento: dispatchEvent
                                    const dispatched = btn.dispatchEvent(ev);

                                    // Segundo intento: .click() directo
                                    if (typeof btn.click === 'function') {
                                        btn.click();
                                    }

                                    // Si tiene onclick en atributo (RichFaces.ajax(...)), eval√∫alo como refuerzo
                                    const attr = btn.getAttribute('onclick');
                                    if (attr) {
                                        try {
                                            eval(attr.replace('return false;', ''));
                                        } catch (e) {
                                            console.error("Error eval onclick btnMuestraDV din√°mico:", e);
                                        }
                                    }

                                    return true;
                                }
                                """
                            )
                            if res:
                                pr("[OK] Click JS din√°mico ejecutado en btnMuestraDV.", "OK")
                                ok = True
                            else:
                                pr("[WARN] No se encontr√≥ din√°micamente el bot√≥n btnMuestraDV.", "WARN")
                        except Exception as e:
                            pr(f"[ERROR] Fallback JS din√°mico fall√≥ en btnMuestraDV: {e}", "ERROR")

                    # 3) Siempre intentamos esperar loader tras el intento de click
                    try:
                        await wait_for_loader(filtros_tab, timeout=20000)
                        pr("Loader tras btnMuestraDV completado (o timeout manejado).", "INFO")
                    except Exception:
                        pr("Loader tras btnMuestraDV no se detect√≥ claramente.", "WARN")

                    return ok

                # =========================
                # Reintentos + verificaci√≥n de panel visible
                # =========================
                max_intentos_btn = 3
                popup_abierto = False

                for intento in range(1, max_intentos_btn + 1):
                    pr(f"Intento #{intento} para abrir Datos Variables Cobertura (btnMuestraDV)...", "INFO")

                    _ = await click_btn_muestra_dv_once()
                    await asyncio.sleep(1.0)

                    # Verificar si el panel flotante se muestra (mismo DOM, no popup de ventana)
                    try:
                        visible = await filtros_tab.evaluate(
                            """
                            (sel) => {
                                const el = document.querySelector(sel);
                                if (!el) return false;
                                const style = window.getComputedStyle(el);
                                const visible = el.offsetParent !== null &&
                                                style.visibility !== 'hidden' &&
                                                style.display !== 'none';
                                return visible;
                            }
                            """,
                            POPUP_DV_SEL,
                        )
                    except Exception as e:
                        pr(f"[WARN] No se pudo evaluar visibilidad de popupDVCoberturas tras intento #{intento}: {e}",
                           "WARN")
                        visible = False

                    if visible:
                        popup_abierto = True
                        pr("Panel 'popupDVCoberturas' visible tras click en btnMuestraDV.", "OK")
                        break
                    else:
                        pr(
                            f"Panel popupDVCoberturas NO visible tras intento #{intento} de btnMuestraDV.",
                            "WARN",
                        )
                        if intento < max_intentos_btn:
                            pr("Reintentando btnMuestraDV...", "INFO")
                        else:
                            pr(
                                "[ERROR] No se logr√≥ abrir Datos Variables Cobertura despu√©s de varios intentos.",
                                "ERROR",
                            )

                # ============================================================
                # 11) Si el panel est√° abierto, validar contenido y dar ACEPTAR
                # ============================================================
                if popup_abierto:
                    # Leer t√≠tulo del panel (debug)
                    try:
                        hdr = await filtros_tab.inner_text(POPUP_HDR_SEL)
                        pr(f"T√≠tulo panel DV: '{hdr.strip()}'", "INFO")
                    except Exception:
                        pr("No se pudo leer mensajeDV del panel DV.", "WARN")

                    # Verificar select de deducible (aunque ya est√© en 0 - 0% SMMLV)
                    try:
                        await filtros_tab.wait_for_selector(DV_COB_SELECT_SEL, timeout=10000)
                        pr("Select de Opci√≥n De Deducible (dvCoberturasPoliza) presente.", "INFO")
                    except Exception as e:
                        pr(f"No se encontr√≥ dvCoberturasPoliza en el panel DV: {e}", "WARN")

                    # ========================================================
                    # Click en "Aceptar" del popup DV Coberturas (ID puede variar)
                    # <input id="formaDV:j_idt212" ... value="Aceptar" type="submit">
                    # ========================================================

                    BTN_DV_OK_SELECTORS = [
                        # 1) M√°s espec√≠fico: dentro del contenedor del popup
                        "div#formaDV\\:popupDVCoberturas_container input[type='submit'][value='Aceptar']",
                        # 2) ID que empiece por formaDV:j_idt (207, 212, etc.)
                        "input[id^='formaDV:j_idt'][type='submit'][value='Aceptar']",
                        # 3) Por tabindex t√≠pico de ese bot√≥n
                        "input[type='submit'][value='Aceptar'][tabindex='9999']",
                        # 4) XPath dentro del popup
                        "xpath=//div[@id='formaDV:popupDVCoberturas_container']//input[@type='submit' and @value='Aceptar']",
                        # 5) XPath gen√©rico (√∫ltimo recurso)
                        "xpath=//input[@type='submit' and @value='Aceptar']",
                    ]

                    async def click_btn_aceptar_dv_once() -> bool:
                        ok = False

                        # 1) Click humano con varios selectores
                        for sel in BTN_DV_OK_SELECTORS:
                            try:
                                await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                                btn_ok = filtros_tab.locator(sel)
                                await btn_ok.scroll_into_view_if_needed()
                                await btn_ok.hover()
                                await asyncio.sleep(0.3)
                                await btn_ok.click(force=True)
                                pr(f"[OK] Click humano en 'Aceptar' (popup DV) con selector '{sel}'.", "OK")
                                ok = True

                                # Segundo intento suave (por si el primero no engancha RichFaces)
                                await asyncio.sleep(0.2)
                                try:
                                    await btn_ok.click(force=True)
                                    pr(f"[INFO] Segundo click en 'Aceptar' (popup DV) con '{sel}'.", "INFO")
                                except Exception:
                                    pass

                                break
                            except Exception as e:
                                pr(f"[WARN] Click humano fall√≥ en 'Aceptar' (popup DV) con '{sel}': {e}", "WARN")

                        # 2) Fallback JS: buscar din√°micamente el bot√≥n dentro del popup y hacer click
                        if not ok:
                            try:
                                res = await filtros_tab.evaluate(
                                    """
                                    (popupSel) => {
                                        const popup = document.querySelector(popupSel);
                                        if (!popup) return false;

                                        // Buscar el input submit con value='Aceptar' dentro del popup
                                        const btns = popup.querySelectorAll("input[type='submit']");
                                        let btn = null;
                                        for (const b of btns) {
                                            if ((b.value || '').trim().toUpperCase() === 'ACEPTAR') {
                                                btn = b;
                                                break;
                                            }
                                        }
                                        if (!btn) return false;

                                        const ev = new MouseEvent('click', {
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        });

                                        // Si tiene onclick como funci√≥n, √∫salo
                                        if (typeof btn.onclick === 'function') {
                                            btn.onclick(ev);
                                        } else {
                                            btn.dispatchEvent(ev);
                                        }

                                        // Por si RichFaces engancha el atributo onclick (string)
                                        const attr = btn.getAttribute('onclick');
                                        if (attr) {
                                            try {
                                                eval(attr.replace('return false;', ''));
                                            } catch (e) {
                                                console.error("Error eval onclick Aceptar din√°mico:", e);
                                            }
                                        }
                                        return true;
                                    }
                                    """,
                                    POPUP_DV_SEL,
                                )
                                if res:
                                    pr("[OK] Click JS din√°mico en 'Aceptar' dentro del popup DV.", "OK")
                                    ok = True
                                else:
                                    pr("[WARN] No se encontr√≥ bot√≥n 'Aceptar' din√°micamente en el popup DV.", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS din√°mico fall√≥ en 'Aceptar' (popup DV): {e}", "ERROR")

                        # 3) Esperar loader tras el click (aunque el click sea dudoso)
                        try:
                            await wait_for_loader(filtros_tab, timeout=20000)
                            pr("Loader posterior a 'Aceptar' (popup DV) completado o timeout manejado.", "INFO")
                        except Exception:
                            pr("Loader tras 'Aceptar' (popup DV) no se detect√≥ claramente.", "WARN")

                        return ok

                    # Reintentos y verificaci√≥n de cierre del popup
                    max_intentos_aceptar = 3
                    for intento in range(1, max_intentos_aceptar + 1):
                        pr(f"Intento #{intento} click en 'Aceptar' (popup DV)...", "INFO")
                        _ = await click_btn_aceptar_dv_once()

                        # Verificar si el panel sigue visible
                        try:
                            visible = await filtros_tab.evaluate(
                                """
                                (sel) => {
                                    const el = document.querySelector(sel);
                                    if (!el) return false;
                                    const style = window.getComputedStyle(el);
                                    const visible = el.offsetParent !== null &&
                                                    style.visibility !== 'hidden' &&
                                                    style.display !== 'none';
                                    return visible;
                                }
                                """,
                                POPUP_DV_SEL,
                            )
                        except Exception as e:
                            pr(f"[WARN] No se pudo evaluar visibilidad del panel DV tras Aceptar: {e}", "WARN")
                            visible = False

                        if not visible:
                            pr("Panel Datos Variables Cobertura parece estar cerrado tras 'Aceptar'.", "OK")
                            break
                        else:
                            pr("Panel DV sigue visible tras 'Aceptar', reintentando...", "WARN")
                            await asyncio.sleep(1.0)
                else:
                    pr("Panel DV Coberturas no se abri√≥; se omite el click en 'Aceptar'.", "WARN")

                # ============================================================
                # X) EDITAR Cobertura Fila 1 -> Da√±o total (btnMuestraDV fila 1)
                #    <input id="formaCoberturas:table:1:btnMuestraDV" ...>
                #    Abre el mismo panel flotante de Datos Variables Cobertura
                # ============================================================

                POPUP_DV_SEL = "#formaDV\\:popupDVCoberturas_container"
                POPUP_HDR_SEL = "#formaDV\\:mensajeDV"
                DV_COB_SELECT_SEL = "#formaDV\\:dvCoberturasPoliza"

                # Par√°metros para la opci√≥n de deducible (Da√±o total)
                DV_DANO_TOTAL_VALUE = CONFIG.get("dv_dano_total_value", "118")  # value por defecto
                DV_DANO_TOTAL_TEXT = (CONFIG.get("dv_dano_total_text") or "118 - 0 % 0 SMMLV").strip()

                # Selectores para el bot√≥n EDITAR de la fila 1
                EDIT_F1_SELECTORS = [
                    "#formaCoberturas\\:table\\:1\\:btnMuestraDV",  # ID t√≠pico fila 1
                    "input[name='formaCoberturas:table:1:btnMuestraDV']",  # name t√≠pico
                    "input[type='image'][name='formaCoberturas:table:1:btnMuestraDV']",  # type=image + name
                    "xpath=//table[@id='formaCoberturas:table']//tr[2]//input[contains(@src,'edit.gif')]",
                    # segunda fila
                    # √öltimo recurso gen√©rico (cualquier edit.gif con title='1')
                    "xpath=//input[@type='image' and contains(@src,'edit.gif') and @title='1']",
                ]

                pr("Intentando abrir panel DV Cobertura para fila 1 (Da√±o total)...", "INFO")

                async def click_btn_muestra_dv_fila1_once() -> bool:
                    """
                    Un solo intento de disparar el bot√≥n EDITAR (btnMuestraDV) de la fila 1
                    usando varios m√©todos. Devuelve True si cree que lanz√≥ el evento.
                    """
                    ok = False

                    # 1) Click "humano" sobre varios selectores
                    for sel in EDIT_F1_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                            btn = filtros_tab.locator(sel)
                            await btn.scroll_into_view_if_needed()
                            await btn.hover()
                            await asyncio.sleep(0.3)

                            # Primer click
                            await btn.click(force=True)
                            pr(f"[OK] Click humano en btnMuestraDV (fila 1) con selector '{sel}'.", "OK")
                            ok = True

                            # Segundo click suave (simular doble click / insistencia)
                            await asyncio.sleep(0.2)
                            try:
                                await btn.click(force=True)
                                pr(f"[INFO] Segundo click en btnMuestraDV (fila 1) con '{sel}'.", "INFO")
                            except Exception:
                                pass

                            break
                        except Exception as e:
                            pr(f"[WARN] Click humano fall√≥ en btnMuestraDV (fila 1) con '{sel}': {e}", "WARN")

                    # 2) Fallback JS din√°mico sobre la fila 1
                    if not ok:
                        try:
                            res = await filtros_tab.evaluate(
                                """
                                () => {
                                    const table = document.getElementById('formaCoberturas:table');
                                    if (!table) return false;

                                    // Fila 1 = segundo <tr> de tbody (si el primero es encabezado, ajusta seg√∫n DOM real)
                                    let btn = table.querySelector("tr:nth-of-type(2) input[name*='btnMuestraDV'][type='image']");
                                    if (!btn) {
                                        // Por title = '1'
                                        btn = table.querySelector("tr:nth-of-type(2) input[type='image'][title='1']")
                                           || table.querySelector("input[type='image'][name*='table:1:btnMuestraDV']");
                                    }
                                    if (!btn) return false;

                                    const ev = new MouseEvent('click', {
                                        bubbles: true,
                                        cancelable: true,
                                        view: window
                                    });

                                    // Click 1
                                    btn.dispatchEvent(ev);
                                    if (typeof btn.click === 'function') btn.click();

                                    // Refuerzo: eval del onclick RichFaces
                                    const attr = btn.getAttribute('onclick');
                                    if (attr) {
                                        try {
                                            eval(attr.replace('return false;', ''));
                                        } catch (e) {
                                            console.error("Error eval onclick btnMuestraDV fila 1:", e);
                                        }
                                    }

                                    return true;
                                }
                                """
                            )
                            if res:
                                pr("[OK] Click JS din√°mico ejecutado en btnMuestraDV (fila 1).", "OK")
                                ok = True
                            else:
                                pr("[WARN] No se encontr√≥ din√°micamente btnMuestraDV (fila 1).", "WARN")
                        except Exception as e:
                            pr(f"[ERROR] Fallback JS din√°mico fall√≥ en btnMuestraDV (fila 1): {e}", "ERROR")

                    # Siempre intentar esperar loader tras los intentos
                    try:
                        await wait_for_loader(filtros_tab, timeout=20000)
                        pr("Loader tras btnMuestraDV (fila 1) completado (o timeout manejado).", "INFO")
                    except Exception:
                        pr("Loader tras btnMuestraDV (fila 1) no se detect√≥ claramente.", "WARN")

                    return ok

                # =========================
                # Reintentos + verificaci√≥n de panel visible (fila 1)
                # =========================
                max_intentos_btn_f1 = 3
                popup_abierto_f1 = False

                for intento in range(1, max_intentos_btn_f1 + 1):
                    pr(f"Intento #{intento} para abrir DV Cobertura fila 1 (Da√±o total)...", "INFO")

                    _ = await click_btn_muestra_dv_fila1_once()
                    await asyncio.sleep(1.0)

                    try:
                        visible = await filtros_tab.evaluate(
                            """
                            (sel) => {
                                const el = document.querySelector(sel);
                                if (!el) return false;
                                const style = window.getComputedStyle(el);
                                const visible = el.offsetParent !== null &&
                                                style.visibility !== 'hidden' &&
                                                style.display !== 'none';
                                return visible;
                            }
                            """,
                            POPUP_DV_SEL,
                        )
                    except Exception as e:
                        pr(f"[WARN] No se pudo evaluar visibilidad popupDVCoberturas (fila 1): {e}", "WARN")
                        visible = False

                    if visible:
                        popup_abierto_f1 = True
                        pr("Panel 'popupDVCoberturas' visible para fila 1 (Da√±o total).", "OK")
                        break
                    else:
                        pr("Panel DV Coberturas NO visible a√∫n para fila 1.", "WARN")
                        if intento < max_intentos_btn_f1:
                            pr("Reintentando click en btnMuestraDV (fila 1)...", "INFO")
                        else:
                            pr("[ERROR] No se logr√≥ abrir DV Cobertura fila 1 despu√©s de varios intentos.", "ERROR")

                # ============================================================
                # Si el panel est√° abierto para fila 1 -> seleccionar deducible y Aceptar
                # ============================================================
                if popup_abierto_f1:
                    # Debug t√≠tulo: deber√≠a mostrar "371 : Da√±o total"
                    try:
                        hdr = await filtros_tab.inner_text(POPUP_HDR_SEL)
                        pr(f"T√≠tulo panel DV (fila 1): '{hdr.strip()}'", "INFO")
                    except Exception:
                        pr("No se pudo leer mensajeDV del panel DV (fila 1).", "WARN")

                    # Asegurar que el select de deducible est√© presente
                    try:
                        await filtros_tab.wait_for_selector(DV_COB_SELECT_SEL, timeout=10000)
                        pr("Select Opci√≥n De Deducible (dvCoberturasPoliza) presente (fila 1).", "INFO")
                    except Exception as e:
                        pr(f"No se encontr√≥ dvCoberturasPoliza en el panel DV (fila 1): {e}", "WARN")

                    # ---------------------------
                    # Seleccionar opci√≥n parametrizable
                    # ---------------------------
                    async def intentar_fijar_deducible_fila1() -> bool:
                        ok = await select_option_by_text(
                            filtros_tab,
                            DV_COB_SELECT_SEL,
                            DV_DANO_TOTAL_TEXT,
                            f"Deductible Da√±o total (value={DV_DANO_TOTAL_VALUE})",
                            wait_ajax_ms=1500,
                        )
                        return ok

                    max_intentos_ded = 3
                    ok_final_ded = False
                    curr_value_ded, curr_text_ded = None, ""

                    for intento in range(1, max_intentos_ded + 1):
                        pr(f"Intento #{intento} para fijar deducible Da√±o total -> '{DV_DANO_TOTAL_TEXT}'", "INFO")

                        ok_try = await intentar_fijar_deducible_fila1()
                        await asyncio.sleep(1.0)

                        # Leer estado real del select
                        try:
                            curr_value_ded, curr_text_ded = await filtros_tab.eval_on_selector(
                                DV_COB_SELECT_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.text : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value_ded, curr_text_ded = None, ""
                            pr(f"No se pudo leer estado de dvCoberturasPoliza (fila 1): {e}", "ERROR")

                        pr(
                            f"Estado dvCoberturasPoliza (fila 1) -> value='{curr_value_ded}', text='{curr_text_ded}'",
                            "DEBUG",
                        )

                        if ok_try and (
                                curr_value_ded == DV_DANO_TOTAL_VALUE
                                or curr_text_ded.strip().upper() == DV_DANO_TOTAL_TEXT.upper()
                        ):
                            pr("Deducible Da√±o total qued√≥ fijado correctamente en el popup (fila 1).", "OK")
                            ok_final_ded = True
                            break
                        else:
                            pr(
                                "Deducible Da√±o total a√∫n no coincide, reintentando‚Ä¶ "
                                f"(esperado value='{DV_DANO_TOTAL_VALUE}', text='{DV_DANO_TOTAL_TEXT}')",
                                "WARN",
                            )
                            await asyncio.sleep(1.0)

                    if not ok_final_ded:
                        pr(
                            f"[ERROR] No se pudo fijar deducible Da√±o total en '{DV_DANO_TOTAL_TEXT}' "
                            f"(value='{DV_DANO_TOTAL_VALUE}') tras {max_intentos_ded} intentos.",
                            "ERROR",
                        )

                    # ---------------------------
                    # Click en Aceptar del popup (mismo patr√≥n gen√©rico)
                    # ---------------------------
                    BTN_DV_OK_SELECTORS = [
                        "div#formaDV\\:popupDVCoberturas_container input[type='submit'][value='Aceptar']",
                        "input[id^='formaDV:j_idt'][type='submit'][value='Aceptar']",
                        "input[type='submit'][value='Aceptar'][tabindex='9999']",
                        "xpath=//div[@id='formaDV:popupDVCoberturas_container']//input[@type='submit' and @value='Aceptar']",
                        "xpath=//input[@type='submit' and @value='Aceptar']",
                    ]

                    async def click_btn_aceptar_dv_fila1_once() -> bool:
                        ok = False

                        # 1) Click humano con varios selectores
                        for sel in BTN_DV_OK_SELECTORS:
                            try:
                                await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                                btn_ok = filtros_tab.locator(sel)
                                await btn_ok.scroll_into_view_if_needed()
                                await btn_ok.hover()
                                await asyncio.sleep(0.3)
                                await btn_ok.click(force=True)
                                pr(f"[OK] Click humano en 'Aceptar' (popup DV fila 1) con '{sel}'.", "OK")
                                ok = True

                                # Segundo click suave
                                await asyncio.sleep(0.2)
                                try:
                                    await btn_ok.click(force=True)
                                    pr(f"[INFO] Segundo click en 'Aceptar' (popup DV fila 1) con '{sel}'.", "INFO")
                                except Exception:
                                    pass

                                break
                            except Exception as e:
                                pr(f"[WARN] Click humano fall√≥ en 'Aceptar' (fila 1) con '{sel}': {e}", "WARN")

                        # 2) Fallback JS din√°mico dentro del popup
                        if not ok:
                            try:
                                res = await filtros_tab.evaluate(
                                    """
                                    (popupSel) => {
                                        const popup = document.querySelector(popupSel);
                                        if (!popup) return false;

                                        const btns = popup.querySelectorAll("input[type='submit']");
                                        let btn = null;
                                        for (const b of btns) {
                                            if ((b.value || '').trim().toUpperCase() === 'ACEPTAR') {
                                                btn = b;
                                                break;
                                            }
                                        }
                                        if (!btn) return false;

                                        const ev = new MouseEvent('click', {
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        });

                                        if (typeof btn.onclick === 'function') {
                                            btn.onclick(ev);
                                        } else {
                                            btn.dispatchEvent(ev);
                                        }

                                        const attr = btn.getAttribute('onclick');
                                        if (attr) {
                                            try {
                                                eval(attr.replace('return false;', ''));
                                            } catch (e) {
                                                console.error("Error eval onclick Aceptar fila 1:", e);
                                            }
                                        }
                                        return true;
                                    }
                                    """,
                                    POPUP_DV_SEL,
                                )
                                if res:
                                    pr("[OK] Click JS din√°mico en 'Aceptar' dentro del popup DV (fila 1).", "OK")
                                    ok = True
                                else:
                                    pr("[WARN] No se encontr√≥ bot√≥n 'Aceptar' din√°micamente (fila 1).", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS din√°mico fall√≥ en 'Aceptar' (fila 1): {e}", "ERROR")

                        # Loader tras click en Aceptar
                        try:
                            await wait_for_loader(filtros_tab, timeout=20000)
                            pr("Loader posterior a 'Aceptar' (popup DV fila 1) completado o timeout manejado.", "INFO")
                        except Exception:
                            pr("Loader tras 'Aceptar' (popup DV fila 1) no se detect√≥ claramente.", "WARN")

                        return ok

                    # Reintentos y verificaci√≥n de cierre del panel
                    max_intentos_aceptar_f1 = 3
                    for intento in range(1, max_intentos_aceptar_f1 + 1):
                        pr(f"Intento #{intento} click en 'Aceptar' (popup DV fila 1)...", "INFO")
                        _ = await click_btn_aceptar_dv_fila1_once()

                        try:
                            visible = await filtros_tab.evaluate(
                                """
                                (sel) => {
                                    const el = document.querySelector(sel);
                                    if (!el) return false;
                                    const style = window.getComputedStyle(el);
                                    const visible = el.offsetParent !== null &&
                                                    style.visibility !== 'hidden' &&
                                                    style.display !== 'none';
                                    return visible;
                                }
                                """,
                                POPUP_DV_SEL,
                            )
                        except Exception as e:
                            pr(f"[WARN] No se pudo evaluar visibilidad del panel DV (fila 1) tras Aceptar: {e}", "WARN")
                            visible = False

                        if not visible:
                            pr("Panel DV Coberturas (fila 1) parece estar cerrado tras 'Aceptar'.", "OK")
                            break
                        else:
                            pr("Panel DV (fila 1) sigue visible tras 'Aceptar', reintentando...", "WARN")
                            await asyncio.sleep(1.0)
                else:
                    pr("Panel DV Coberturas (fila 1) no se abri√≥; se omite selecci√≥n y Aceptar.", "WARN")

                # ============================================================
                # X) EDITAR Cobertura Fila 3 -> (btnMuestraDV fila 3)
                #    <input id="formaCoberturas:table:3:btnMuestraDV" ...>
                #    Abre el panel flotante de Datos Variables Cobertura
                # ============================================================

                POPUP_DV_SEL = "#formaDV\\:popupDVCoberturas_container"
                POPUP_HDR_SEL = "#formaDV\\:mensajeDV"
                DV_COB_SELECT_SEL = "#formaDV\\:dvCoberturasPoliza"

                # Par√°metros para la opci√≥n de deducible de la fila 3 (parametrizable)
                DV_F3_VALUE = CONFIG.get("dv_cob_fila3_value", "118")
                DV_F3_TEXT = (CONFIG.get("dv_cob_fila3_text") or "118 - 0 % 0 SMMLV").strip()

                # Selectores para el bot√≥n EDITAR de la fila 3
                EDIT_F3_SELECTORS = [
                    "#formaCoberturas\\:table\\:3\\:btnMuestraDV",  # ID t√≠pico fila 3
                    "input[name='formaCoberturas:table:3:btnMuestraDV']",  # name t√≠pico
                    "input[type='image'][name='formaCoberturas:table:3:btnMuestraDV']",  # type=image + name
                    "xpath=//input[@type='image' and contains(@name,'table:3:btnMuestraDV')]",  # gen√©rico por name
                    "xpath=//input[@type='image' and @title='3' and contains(@src,'edit.gif')]",  # por title=3
                ]

                pr("Intentando abrir panel DV Cobertura para fila 3...", "INFO")

                async def click_btn_muestra_dv_fila3_once() -> bool:
                    """
                    Un solo intento de disparar el bot√≥n EDITAR (btnMuestraDV) de la fila 3
                    usando varios m√©todos. Devuelve True si cree que lanz√≥ el evento.
                    """
                    ok = False

                    # 1) Click "humano" sobre varios selectores (con doble click suave)
                    for sel in EDIT_F3_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                            btn = filtros_tab.locator(sel)
                            await btn.scroll_into_view_if_needed()
                            await btn.hover()
                            await asyncio.sleep(0.3)

                            # Primer click
                            await btn.click(force=True)
                            pr(f"[OK] Click humano en btnMuestraDV (fila 3) con selector '{sel}'.", "OK")
                            ok = True

                            # Segundo click suave (refuerzo tipo doble click)
                            await asyncio.sleep(0.2)
                            try:
                                await btn.click(force=True)
                                pr(f"[INFO] Segundo click en btnMuestraDV (fila 3) con '{sel}'.", "INFO")
                            except Exception:
                                pass

                            break
                        except Exception as e:
                            pr(f"[WARN] Click humano fall√≥ en btnMuestraDV (fila 3) con '{sel}': {e}", "WARN")

                    # 2) Fallback JS din√°mico: buscar la fila 3 de la tabla y el bot√≥n edit
                    if not ok:
                        try:
                            res = await filtros_tab.evaluate(
                                """
                                () => {
                                    const table = document.getElementById('formaCoberturas:table');
                                    if (!table) return false;

                                    // Fila 3 => cuarta fila "real" (ajusta seg√∫n DOM real si hay encabezado)
                                    let btn = table.querySelector("tr:nth-of-type(4) input[name*='btnMuestraDV'][type='image']");
                                    if (!btn) {
                                        // Buscar por title='3'
                                        btn = table.querySelector("tr:nth-of-type(4) input[type='image'][title='3']")
                                           || table.querySelector("input[type='image'][name*='table:3:btnMuestraDV']");
                                    }
                                    if (!btn) return false;

                                    const ev = new MouseEvent('click', {
                                        bubbles: true,
                                        cancelable: true,
                                        view: window
                                    });

                                    // Click 1
                                    btn.dispatchEvent(ev);
                                    if (typeof btn.click === 'function') btn.click();

                                    // Refuerzo: eval del onclick RichFaces
                                    const attr = btn.getAttribute('onclick');
                                    if (attr) {
                                        try {
                                            eval(attr.replace('return false;', ''));
                                        } catch (e) {
                                            console.error("Error eval onclick btnMuestraDV fila 3:", e);
                                        }
                                    }

                                    return true;
                                }
                                """
                            )
                            if res:
                                pr("[OK] Click JS din√°mico ejecutado en btnMuestraDV (fila 3).", "OK")
                                ok = True
                            else:
                                pr("[WARN] No se encontr√≥ din√°micamente btnMuestraDV (fila 3).", "WARN")
                        except Exception as e:
                            pr(f"[ERROR] Fallback JS din√°mico fall√≥ en btnMuestraDV (fila 3): {e}", "ERROR")

                    # Siempre intentar esperar loader tras los intentos
                    try:
                        await wait_for_loader(filtros_tab, timeout=20000)
                        pr("Loader tras btnMuestraDV (fila 3) completado (o timeout manejado).", "INFO")
                    except Exception:
                        pr("Loader tras btnMuestraDV (fila 3) no se detect√≥ claramente.", "WARN")

                    return ok

                # =========================
                # Reintentos + verificaci√≥n popup visible (fila 3)
                # =========================
                max_intentos_btn_f3 = 3
                popup_abierto_f3 = False

                for intento in range(1, max_intentos_btn_f3 + 1):
                    pr(f"Intento #{intento} para abrir DV Cobertura fila 3...", "INFO")

                    _ = await click_btn_muestra_dv_fila3_once()
                    await asyncio.sleep(1.0)

                    try:
                        visible = await filtros_tab.evaluate(
                            """
                            (sel) => {
                                const el = document.querySelector(sel);
                                if (!el) return false;
                                const style = window.getComputedStyle(el);
                                const visible = el.offsetParent !== null &&
                                                style.visibility !== 'hidden' &&
                                                style.display !== 'none';
                                return visible;
                            }
                            """,
                            POPUP_DV_SEL,
                        )
                    except Exception as e:
                        pr(f"[WARN] No se pudo evaluar visibilidad popupDVCoberturas (fila 3): {e}", "WARN")
                        visible = False

                    if visible:
                        popup_abierto_f3 = True
                        pr("Panel 'popupDVCoberturas' visible para fila 3.", "OK")
                        break
                    else:
                        pr("Panel DV Coberturas NO visible a√∫n para fila 3.", "WARN")
                        if intento < max_intentos_btn_f3:
                            pr("Reintentando click en btnMuestraDV (fila 3)...", "INFO")
                        else:
                            pr("[ERROR] No se logr√≥ abrir DV Cobertura fila 3 despu√©s de varios intentos.", "ERROR")

                # ============================================================
                # Si el panel est√° abierto para fila 3 -> seleccionar deducible y Aceptar
                # ============================================================
                if popup_abierto_f3:
                    # Debug t√≠tulo: deber√≠a cambiar seg√∫n la cobertura (ej. Da√±o total / otra)
                    try:
                        hdr = await filtros_tab.inner_text(POPUP_HDR_SEL)
                        pr(f"T√≠tulo panel DV (fila 3): '{hdr.strip()}'", "INFO")
                    except Exception:
                        pr("No se pudo leer mensajeDV del panel DV (fila 3).", "WARN")

                    # Asegurar que el select de deducible est√© presente
                    try:
                        await filtros_tab.wait_for_selector(DV_COB_SELECT_SEL, timeout=10000)
                        pr("Select Opci√≥n De Deducible (dvCoberturasPoliza) presente (fila 3).", "INFO")
                    except Exception as e:
                        pr(f"No se encontr√≥ dvCoberturasPoliza en el panel DV (fila 3): {e}", "WARN")

                    # ---------------------------
                    # Seleccionar opci√≥n parametrizable
                    # ---------------------------
                    async def intentar_fijar_deducible_fila3() -> bool:
                        ok = await select_option_by_text(
                            filtros_tab,
                            DV_COB_SELECT_SEL,
                            DV_F3_TEXT,
                            f"Deductible fila 3 (value={DV_F3_VALUE})",
                            wait_ajax_ms=1500,
                        )
                        return ok

                    max_intentos_ded_f3 = 3
                    ok_final_ded_f3 = False
                    curr_value_ded_f3, curr_text_ded_f3 = None, ""

                    for intento in range(1, max_intentos_ded_f3 + 1):
                        pr(f"Intento #{intento} para fijar deducible fila 3 -> '{DV_F3_TEXT}'", "INFO")

                        ok_try = await intentar_fijar_deducible_fila3()
                        await asyncio.sleep(1.0)

                        # Leer estado real del select
                        try:
                            curr_value_ded_f3, curr_text_ded_f3 = await filtros_tab.eval_on_selector(
                                DV_COB_SELECT_SEL,
                                """el => {
                                    if (!el) return [null, ""];
                                    const val = el.value || null;
                                    const opt = el.options[el.selectedIndex] || null;
                                    const txt = opt ? opt.text : "";
                                    return [val, txt];
                                }"""
                            )
                        except Exception as e:
                            curr_value_ded_f3, curr_text_ded_f3 = None, ""
                            pr(f"No se pudo leer estado de dvCoberturasPoliza (fila 3): {e}", "ERROR")

                        pr(
                            f"Estado dvCoberturasPoliza (fila 3) -> value='{curr_value_ded_f3}', text='{curr_text_ded_f3}'",
                            "DEBUG",
                        )

                        if ok_try and (
                                curr_value_ded_f3 == DV_F3_VALUE
                                or curr_text_ded_f3.strip().upper() == DV_F3_TEXT.upper()
                        ):
                            pr("Deducible fila 3 qued√≥ fijado correctamente en el popup.", "OK")
                            ok_final_ded_f3 = True
                            break
                        else:
                            pr(
                                "Deducible fila 3 a√∫n no coincide, reintentando‚Ä¶ "
                                f"(esperado value='{DV_F3_VALUE}', text='{DV_F3_TEXT}')",
                                "WARN",
                            )
                            await asyncio.sleep(1.0)

                    if not ok_final_ded_f3:
                        pr(
                            f"[ERROR] No se pudo fijar deducible fila 3 en '{DV_F3_TEXT}' "
                            f"(value='{DV_F3_VALUE}') tras {max_intentos_ded_f3} intentos.",
                            "ERROR",
                        )

                    # ---------------------------
                    # Click en Aceptar del popup DV Coberturas (ID din√°mico)
                    # ---------------------------
                    BTN_DV_OK_SELECTORS_F3 = [
                        "div#formaDV\\:popupDVCoberturas_container input[type='submit'][value='Aceptar']",
                        "input[id^='formaDV:j_idt'][type='submit'][value='Aceptar']",
                        "input[type='submit'][value='Aceptar'][tabindex='9999']",
                        "xpath=//div[@id='formaDV:popupDVCoberturas_container']//input[@type='submit' and @value='Aceptar']",
                        "xpath=//input[@type='submit' and @value='Aceptar']",
                    ]

                    async def click_btn_aceptar_dv_fila3_once() -> bool:
                        ok = False

                        # 1) Click humano con varios selectores (doble click suave)
                        for sel in BTN_DV_OK_SELECTORS_F3:
                            try:
                                await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                                btn_ok = filtros_tab.locator(sel)
                                await btn_ok.scroll_into_view_if_needed()
                                await btn_ok.hover()
                                await asyncio.sleep(0.3)
                                await btn_ok.click(force=True)
                                pr(f"[OK] Click humano en 'Aceptar' (popup DV fila 3) con '{sel}'.", "OK")
                                ok = True

                                # Segundo click
                                await asyncio.sleep(0.2)
                                try:
                                    await btn_ok.click(force=True)
                                    pr(f"[INFO] Segundo click en 'Aceptar' (popup DV fila 3) con '{sel}'.", "INFO")
                                except Exception:
                                    pass

                                break
                            except Exception as e:
                                pr(f"[WARN] Click humano fall√≥ en 'Aceptar' (fila 3) con '{sel}': {e}", "WARN")

                        # 2) Fallback JS din√°mico dentro del popup
                        if not ok:
                            try:
                                res = await filtros_tab.evaluate(
                                    """
                                    (popupSel) => {
                                        const popup = document.querySelector(popupSel);
                                        if (!popup) return false;

                                        const btns = popup.querySelectorAll("input[type='submit']");
                                        let btn = null;
                                        for (const b of btns) {
                                            if ((b.value || '').trim().toUpperCase() === 'ACEPTAR') {
                                                btn = b;
                                                break;
                                            }
                                        }
                                        if (!btn) return false;

                                        const ev = new MouseEvent('click', {
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        });

                                        if (typeof btn.onclick === 'function') {
                                            btn.onclick(ev);
                                        } else {
                                            btn.dispatchEvent(ev);
                                        }

                                        const attr = btn.getAttribute('onclick');
                                        if (attr) {
                                            try {
                                                eval(attr.replace('return false;', ''));
                                            } catch (e) {
                                                console.error("Error eval onclick Aceptar fila 3:", e);
                                            }
                                        }
                                        return true;
                                    }
                                    """,
                                    POPUP_DV_SEL,
                                )
                                if res:
                                    pr("[OK] Click JS din√°mico en 'Aceptar' dentro del popup DV (fila 3).", "OK")
                                    ok = True
                                else:
                                    pr("[WARN] No se encontr√≥ bot√≥n 'Aceptar' din√°micamente (fila 3).", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS din√°mico fall√≥ en 'Aceptar' (fila 3): {e}", "ERROR")

                        # Loader tras click en Aceptar
                        try:
                            await wait_for_loader(filtros_tab, timeout=20000)
                            pr("Loader posterior a 'Aceptar' (popup DV fila 3) completado o timeout manejado.", "INFO")
                        except Exception:
                            pr("Loader tras 'Aceptar' (popup DV fila 3) no se detect√≥ claramente.", "WARN")

                        return ok

                    # Reintentos y verificaci√≥n de cierre del panel
                    max_intentos_aceptar_f3 = 3
                    for intento in range(1, max_intentos_aceptar_f3 + 1):
                        pr(f"Intento #{intento} click en 'Aceptar' (popup DV fila 3)...", "INFO")
                        _ = await click_btn_aceptar_dv_fila3_once()

                        try:
                            visible = await filtros_tab.evaluate(
                                """
                                (sel) => {
                                    const el = document.querySelector(sel);
                                    if (!el) return false;
                                    const style = window.getComputedStyle(el);
                                    const visible = el.offsetParent !== null &&
                                                    style.visibility !== 'hidden' &&
                                                    style.display !== 'none';
                                    return visible;
                                }
                                """,
                                POPUP_DV_SEL,
                            )
                        except Exception as e:
                            pr(f"[WARN] No se pudo evaluar visibilidad del panel DV (fila 3) tras Aceptar: {e}", "WARN")
                            visible = False

                        if not visible:
                            pr("Panel DV Coberturas (fila 3) parece estar cerrado tras 'Aceptar'.", "OK")
                            break
                        else:
                            pr("Panel DV (fila 3) sigue visible tras 'Aceptar', reintentando...", "WARN")
                            await asyncio.sleep(1.0)
                else:
                    pr("Panel DV Coberturas (fila 3) no se abri√≥; se omite selecci√≥n y Aceptar.", "WARN")

                # ============================================================
                # Helper gen√©rico para botones "Continuar ¬ª" (RichFaces)
                # ============================================================
                async def click_richfaces_continuar(
                        page,
                        base_id: str,
                        desc: str,
                        next_selector: str | None = None,
                        max_intentos: int = 3,
                        loader_timeout: int = 20000,
                ):
                    """
                    Click robusto en un bot√≥n RichFaces tipo:
                      <input id="base_id" name="base_id" ... value="Continuar ¬ª" type="submit">

                    - Usa varios selectores (id, name, xpath, value).
                    - Hace click "humano" + fallback JS (MouseEvent + eval(onclick)).
                    - Espera loader.
                    - Si next_selector != None, intenta validar que el siguiente objeto aparezca.
                    """
                    escaped_id = base_id.replace(":", "\\:")

                    SELECTORS = [
                        f"#{escaped_id}",
                        f"input[id='{base_id}']",
                        f"input[name='{base_id}']",
                        # Por si cambian el id pero no el name
                        f"xpath=//input[@type='submit' and @name='{base_id}']",
                        # Fallback gen√©rico por value "Continuar"
                        "input[type='submit'][value*='Continuar']",
                        "xpath=//input[@type='submit' and contains(@value,'Continuar')]",
                    ]

                    async def intento_click() -> bool:
                        ok = False

                        # 1) Click "humano" probando varios selectores
                        for sel in SELECTORS:
                            try:
                                await page.wait_for_selector(sel, state="visible", timeout=5000)
                                btn = page.locator(sel)
                                await btn.scroll_into_view_if_needed()
                                await btn.hover()
                                await asyncio.sleep(0.3)

                                # Click principal
                                await btn.click(force=True)
                                pr(f"[OK] Click humano en {desc} con selector '{sel}'.", "OK")
                                ok = True

                                # Refuerzo: segundo click suave por si el primero no engancha bien
                                await asyncio.sleep(0.2)
                                try:
                                    await btn.click(force=True)
                                    pr(f"[INFO] Segundo click en {desc} con '{sel}'.", "INFO")
                                except Exception:
                                    pass

                                break
                            except Exception as e:
                                pr(f"[WARN] Click humano fall√≥ en {desc} con '{sel}': {e}", "WARN")

                        # 2) Fallback JS usando el id exacto (MouseEvent + onclick + eval)
                        if not ok:
                            try:
                                res = await page.evaluate(
                                    """
                                    (id) => {
                                        const el = document.getElementById(id);
                                        if (!el) return false;

                                        const ev = new MouseEvent('click', {
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        });

                                        // Si hay onclick como funci√≥n, √∫salo
                                        if (typeof el.onclick === 'function') {
                                            el.onclick(ev);
                                        } else {
                                            el.dispatchEvent(ev);
                                        }

                                        // Por si el onclick est√° s√≥lo como atributo (RichFaces.ajax(...))
                                        const attr = el.getAttribute('onclick');
                                        if (attr) {
                                            try {
                                                eval(attr.replace('return false;', ''));
                                            } catch (e) {
                                                console.error("Error eval onclick continuar:", e);
                                            }
                                        }
                                        return true;
                                    }
                                    """,
                                    base_id,
                                )
                                if res:
                                    pr(f"[OK] Click JS din√°mico disparado en {desc} (id='{base_id}').", "OK")
                                    ok = True
                                else:
                                    pr(f"[WARN] JS din√°mico no encontr√≥/ejecut√≥ {desc} (id='{base_id}').", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS din√°mico fall√≥ en {desc}: {e}", "ERROR")

                        # 3) Siempre esperar loader despu√©s del intento
                        try:
                            await wait_for_loader(page, timeout=loader_timeout)
                            pr(f"Loader posterior a {desc} completado (o timeout manejado).", "INFO")
                        except Exception:
                            pr(f"Loader posterior a {desc} no se detect√≥ claramente.", "WARN")

                        return ok

                    # =========================
                    # Reintentos + validaci√≥n
                    # =========================
                    for intento in range(1, max_intentos + 1):
                        pr(f"Intento #{intento} click en {desc} (id='{base_id}')...", "INFO")
                        _ = await intento_click()

                        # Si no hay next_selector, no validamos nada m√°s
                        if not next_selector:
                            # Peque√±a pausa para darle tiempo a la navegaci√≥n
                            await asyncio.sleep(1.0)
                            return

                        # Validar que el siguiente objeto haya aparecido
                        try:
                            await page.wait_for_selector(next_selector, state="visible", timeout=8000)
                            pr(f"[OK] {desc}: se detect√≥ el siguiente objeto '{next_selector}' visible.", "OK")
                            return
                        except Exception as e:
                            pr(
                                f"[WARN] {desc}: no se encontr√≥ '{next_selector}' tras el intento #{intento} -> {e}",
                                "WARN",
                            )
                            if intento < max_intentos:
                                pr(f"[INFO] Reintentando {desc}...", "INFO")
                                await asyncio.sleep(1.0)
                            else:
                                pr(
                                    f"[ERROR] {desc}: tras {max_intentos} intentos no apareci√≥ '{next_selector}'.",
                                    "ERROR",
                                )

                # ============================================================
                # SECUENCIA DE CLICKS "CONTINUAR ¬ª"
                # ============================================================

                # 1) Continuar en COBERTURAS
                # <input id="formaCoberturas:continuar" ...>
                await click_richfaces_continuar(
                    filtros_tab,
                    base_id="formaCoberturas:continuar",
                    desc="Continuar Coberturas (formaCoberturas:continuar)",
                    next_selector="#agravantesForm\\:btnRiesgoFin",  # siguiente bot√≥n
                )

                # 2) Continuar en AGRAVANTES
                # <input id="agravantesForm:btnRiesgoFin" ...>
                await click_richfaces_continuar(
                    filtros_tab,
                    base_id="agravantesForm:btnRiesgoFin",
                    desc="Continuar Agravantes (agravantesForm:btnRiesgoFin)",
                    next_selector="#CT\\:formaCT\\:continuar",  # bot√≥n CT
                )

                # 3) Continuar en CT
                # <input id="CT:formaCT:continuar" ...>
                await click_richfaces_continuar(
                    filtros_tab,
                    base_id="CT:formaCT:continuar",
                    desc="Continuar CT (CT:formaCT:continuar)",
                    next_selector="#frmRiesgosPoliza\\:continuar",  # bot√≥n riesgos
                )

                # 4) Continuar en RIESGOS POLIZA
                # <input id="frmRiesgosPoliza:continuar" ...>
                # √öltimo: aqu√≠ no te pongo next_selector porque no me diste el siguiente objeto.
                # Si tienes un id claro de la siguiente pantalla, p√°salo en next_selector.
                await click_richfaces_continuar(
                    filtros_tab,
                    base_id="frmRiesgosPoliza:continuar",
                    desc="Continuar Riesgos Poliza (frmRiesgosPoliza:continuar)",
                    next_selector=None,  # o por ejemplo "#frmFinPoliza\\:algo" si luego lo conoces
                )

                # ============================================================
                # Helper gen√©rico para botones RichFaces (Continuar, Expedir, etc.)
                # ============================================================
                async def click_richfaces_button(
                        page,
                        base_id: str,
                        desc: str,
                        value_contains: str,
                        next_selector: str | None = None,
                        max_intentos: int = 3,
                        loader_timeout: int = 20000,
                ):
                    """
                    Click robusto en un bot√≥n RichFaces tipo:
                      <input id="base_id" name="base_id" ... value="Continuar ¬ª" type="submit">
                      <input id="base_id" name="base_id" ... value="Expedir" type="submit">

                    - value_contains: texto que debe ir en el value (ej: "Continuar" o "Expedir").
                    - next_selector: CSS/XPath del siguiente elemento que esperas ver (opcional).
                    """
                    escaped_id = base_id.replace(":", "\\:")

                    SELECTORS = [
                        f"#{escaped_id}",
                        f"input[id='{base_id}']",
                        f"input[name='{base_id}']",
                        # XPath por name
                        f"xpath=//input[@type='submit' and @name='{base_id}']",
                        # Fallback gen√©rico por value
                        f"input[type='submit'][value*='{value_contains}']",
                        f"xpath=//input[@type='submit' and contains(@value,'{value_contains}')]",
                    ]

                    async def intento_click() -> bool:
                        ok = False

                        # 1) Click "humano" probando varios selectores
                        for sel in SELECTORS:
                            try:
                                await page.wait_for_selector(sel, state="visible", timeout=5000)
                                btn = page.locator(sel)
                                await btn.scroll_into_view_if_needed()
                                await btn.hover()
                                await asyncio.sleep(0.3)

                                # Click principal
                                await btn.click(force=True)
                                pr(f"[OK] Click humano en {desc} con selector '{sel}'.", "OK")
                                ok = True

                                # Refuerzo: segundo click suave por si el primero no engancha
                                await asyncio.sleep(0.2)
                                try:
                                    await btn.click(force=True)
                                    pr(f"[INFO] Segundo click en {desc} con '{sel}'.", "INFO")
                                except Exception:
                                    pass
                                break
                            except Exception as e:
                                pr(f"[WARN] Click humano fall√≥ en {desc} con '{sel}': {e}", "WARN")

                        # 2) Fallback JS usando el id exacto (MouseEvent + onclick + eval)
                        if not ok:
                            try:
                                res = await page.evaluate(
                                    """
                                    (id) => {
                                        const el = document.getElementById(id);
                                        if (!el) return false;

                                        const ev = new MouseEvent('click', {
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        });

                                        if (typeof el.onclick === 'function') {
                                            el.onclick(ev);
                                        } else {
                                            el.dispatchEvent(ev);
                                        }

                                        const attr = el.getAttribute('onclick');
                                        if (attr) {
                                            try {
                                                eval(attr.replace('return false;', ''));
                                            } catch (e) {
                                                console.error("Error eval onclick bot√≥n gen√©rico:", e);
                                            }
                                        }
                                        return true;
                                    }
                                    """,
                                    base_id,
                                )
                                if res:
                                    pr(f"[OK] Click JS din√°mico disparado en {desc} (id='{base_id}').", "OK")
                                    ok = True
                                else:
                                    pr(f"[WARN] JS din√°mico no encontr√≥/ejecut√≥ {desc} (id='{base_id}').", "WARN")
                            except Exception as e:
                                pr(f"[ERROR] Fallback JS din√°mico fall√≥ en {desc}: {e}", "ERROR")

                        # 3) Siempre esperar loader despu√©s del intento
                        try:
                            await wait_for_loader(page, timeout=loader_timeout)
                            pr(f"Loader posterior a {desc} completado (o timeout manejado).", "INFO")
                        except Exception:
                            pr(f"Loader posterior a {desc} no se detect√≥ claramente.", "WARN")

                        return ok

                    # =========================
                    # Reintentos + validaci√≥n
                    # =========================
                    for intento in range(1, max_intentos + 1):
                        pr(f"Intento #{intento} click en {desc} (id='{base_id}')...", "INFO")
                        _ = await intento_click()

                        if not next_selector:
                            await asyncio.sleep(1.0)
                            return

                        # Validar que el siguiente objeto haya aparecido
                        try:
                            await page.wait_for_selector(next_selector, state="visible", timeout=8000)
                            pr(f"[OK] {desc}: se detect√≥ el siguiente objeto '{next_selector}' visible.", "OK")
                            return
                        except Exception as e:
                            pr(
                                f"[WARN] {desc}: no se encontr√≥ '{next_selector}' tras el intento #{intento} -> {e}",
                                "WARN",
                            )
                            if intento < max_intentos:
                                pr(f"[INFO] Reintentando {desc}...", "INFO")
                                await asyncio.sleep(1.0)
                            else:
                                pr(
                                    f"[ERROR] {desc}: tras {max_intentos} intentos no apareci√≥ '{next_selector}'.",
                                    "ERROR",
                                )

                # ============================================================
                # 5) Continuar en TEXTOS
                #    <input id="frmTextos:j_idt169" ... value="Continuar ¬ª">
                #    y luego debe aparecer el bot√≥n EXPEDIR
                # ============================================================
                await click_richfaces_button(
                    filtros_tab,
                    base_id="frmTextos:j_idt169",
                    desc="Continuar Textos (frmTextos:j_idt169)",
                    value_contains="Continuar",
                    next_selector="#frmConfirmacion\\:expedir",  # siguiente bot√≥n Expedir
                )

                # ============================================================
                # 6) EXPEDIR
                #    <input id="frmConfirmacion:expedir" ... value="Expedir">
                # ============================================================
                await click_richfaces_button(
                    filtros_tab,
                    base_id="frmConfirmacion:expedir",
                    desc="Expedir p√≥liza (frmConfirmacion:expedir)",
                    value_contains="Expedir",
                    next_selector=None,  # si luego tienes un id de la pantalla final, lo pones aqu√≠
                )

                # ============================================================
                # 7) Capturar n√∫mero de p√≥liza emitida + click en Aceptar Emisi√≥n
                #    <span id="j_idt1202:numPol1">1006005314001</span>
                #    <input id="j_idt1202:btnAceptarEmision" ... value="Aceptar">
                # ============================================================

                # ============================================================
                # CAPTURAR N√öMERO DE P√ìLIZA (numPol1) CON SELECTOR DIN√ÅMICO
                # Y DERIVAR EL ID DEL BOT√ìN "ACEPTAR EMISI√ìN"
                # ============================================================

                numero_poliza_emision = None
                BTN_ACEPTAR_EMISION_ID = None  # lo calculamos en base al span

                pr("Buscando span de n√∫mero de p√≥liza (id termina en 'numPol1')‚Ä¶", "INFO")

                try:
                    # 1) Intento r√°pido usando un selector gen√©rico CSS por sufijo
                    #    span[id$='numPol1']
                    await filtros_tab.wait_for_selector("span[id$='numPol1']", state="visible", timeout=20000)

                    # 2) Leer id y texto usando JS para soportar IDs din√°micos (j_idtXXXX:numPol1)
                    span_info = await filtros_tab.evaluate(
                        """
                        () => {
                            const spans = Array.from(document.querySelectorAll("span[id$='numPol1']"));
                            if (!spans.length) return null;

                            const el = spans[0];
                            const id = el.id || "";
                            const text = (el.textContent || "").trim();
                            return { id, text };
                        }
                        """
                    )

                    if not span_info:
                        pr("[ERROR] No se encontr√≥ ning√∫n <span> cuyo id termine en 'numPol1'.", "ERROR")
                    else:
                        span_id = span_info.get("id") or ""
                        raw_num = span_info.get("text") or ""

                        numero_poliza_emision = raw_num.strip()
                        pr(
                            f"Span numPol1 encontrado: id='{span_id}', n√∫mero de p√≥liza='{numero_poliza_emision}'",
                            "OK",
                        )

                        # ====================================================
                        # Derivar din√°micamente el ID del bot√≥n Aceptar Emisi√≥n
                        # Si el span es 'j_idt1202:numPol1' ‚Üí bot√≥n ser√°
                        # 'j_idt1202:btnAceptarEmision'
                        # ====================================================

                        if ":" in span_id:
                            prefix = span_id.split(":", 1)[0]  # j_idt1202
                            BTN_ACEPTAR_EMISION_ID = f"{prefix}:btnAceptarEmision"
                            pr(
                                f"ID din√°mico para bot√≥n Aceptar Emisi√≥n derivado: '{BTN_ACEPTAR_EMISION_ID}'",
                                "INFO",
                            )
                        else:
                            pr(
                                f"[WARN] El id del span numPol1 ('{span_id}') no contiene ':', "
                                f"no se pudo derivar prefijo para btnAceptarEmision.",
                                "WARN",
                            )

                except Exception as e:
                    pr(f"[ERROR] No se pudo capturar span numPol1 (selector din√°mico): {e}", "ERROR")

                # ============================================================
                # 1.1) Guardar el n√∫mero de p√≥liza en tu resumen_json (si existe)
                # ============================================================

                try:
                    if numero_poliza_emision:
                        if isinstance(resumen_json, dict):
                            resumen_json["numero_poliza"] = numero_poliza_emision
                            pr(f"numero_poliza guardado en resumen_json: {numero_poliza_emision}", "INFO")
                        else:
                            pr("resumen_json no es un dict, se omite guardado de numero_poliza.", "WARN")
                    else:
                        pr("[WARN] numero_poliza_emision est√° vac√≠o, no se guarda en resumen_json.", "WARN")
                except NameError:
                    # Si resumen_json no existe en este contexto, simplemente lo ignoramos
                    pr("[INFO] resumen_json no est√° definido en este contexto, se omite guardado de numero_poliza.",
                       "INFO")

                # En este punto:
                # - numero_poliza_emision tiene el n√∫mero le√≠do (o None si fall√≥)
                # - BTN_ACEPTAR_EMISION_ID tiene el ID din√°mico 'j_idtXXXX:btnAceptarEmision' si se pudo derivar

                # ============================================================
                # CLICK ROBUSTO EN "Aceptar Emisi√≥n" (ID din√°mico)
                # Ejemplo del DOM:
                # <input id="j_idt1199:btnAceptarEmision" ... value="Aceptar">
                # ============================================================

                pr("Buscando bot√≥n din√°mico 'Aceptar Emisi√≥n'...", "INFO")

                ACEPTAR_EMISION_SELECTORS = [
                    "input[type='submit'][value='Aceptar']",
                    "input[value='Aceptar']",
                    "xpath=//input[contains(@id,'btnAceptarEmision') and @type='submit']",
                    "xpath=//input[contains(@name,'btnAceptarEmision') and @type='submit']",
                    "xpath=//input[@type='submit' and contains(@value,'Aceptar')]"
                ]

                BTN_DESC = "Bot√≥n Aceptar Emisi√≥n (din√°mico)"
                max_intentos_aceptar_emision = 3

                async def click_aceptar_emision_once() -> bool:
                    ok = False

                    # 1) CLICK HUMANO CON VARIOS SELECTORES
                    for sel in ACEPTAR_EMISION_SELECTORS:
                        try:
                            await filtros_tab.wait_for_selector(sel, state="visible", timeout=5000)
                            btn = filtros_tab.locator(sel)

                            await btn.scroll_into_view_if_needed()
                            await btn.hover()
                            await asyncio.sleep(0.2)
                            await btn.click(force=True)

                            pr(f"[OK] Click humano en {BTN_DESC} con selector '{sel}'.", "OK")
                            ok = True
                            break
                        except Exception as e:
                            pr(f"[WARN] Click humano fall√≥ con '{sel}': {e}", "WARN")

                    # 2) DOBLE CLICK (algunos botones RichFaces reaccionan mejor)
                    if not ok:
                        for sel in ACEPTAR_EMISION_SELECTORS:
                            try:
                                btn = filtros_tab.locator(sel)
                                await btn.dblclick()
                                pr(f"[OK] Doble click en {BTN_DESC} con '{sel}'.", "OK")
                                ok = True
                                break
                            except:
                                pass

                    # 3) FALLBACK: DISPARAR MouseEvent('click')
                    if not ok:
                        try:
                            result = await filtros_tab.evaluate(
                                """
                                () => {
                                    const btns = Array.from(document.querySelectorAll("input"));
                                    const btn = btns.find(b =>
                                        (b.value||'').trim().toUpperCase()==='ACEPTAR' &&
                                        (b.id||'').includes('btnAceptarEmision')
                                    );
                                    if (!btn) return false;

                                    const ev = new MouseEvent('click', { bubbles:true, cancelable:true });
                                    btn.dispatchEvent(ev);
                                    return true;
                                }
                                """
                            )
                            if result:
                                pr("[OK] Click v√≠a MouseEvent en Aceptar Emisi√≥n.", "OK")
                                ok = True
                        except Exception as e:
                            pr(f"[ERROR] MouseEvent fallback fall√≥: {e}", "ERROR")

                    # 4) FALLBACK: ejecutar onclick del atributo
                    if not ok:
                        try:
                            result2 = await filtros_tab.evaluate(
                                """
                                () => {
                                    const btns = Array.from(document.querySelectorAll("input"));
                                    const btn = btns.find(b =>
                                        (b.value||'').trim().toUpperCase()==='ACEPTAR' &&
                                        (b.id||'').includes('btnAceptarEmision')
                                    );
                                    if (!btn) return false;

                                    const attr = btn.getAttribute('onclick');
                                    if (attr) {
                                        try { eval(attr.replace('return false;', '')); return true; }
                                        catch(e){ return false; }
                                    }
                                    return false;
                                }
                                """
                            )
                            if result2:
                                pr("[OK] onclick/JS eval ejecutado en Aceptar Emisi√≥n.", "OK")
                                ok = True
                        except Exception as e:
                            pr(f"[ERROR] Fallback onclick fall√≥: {e}", "ERROR")

                    # 5) ESPERAR LOADER
                    try:
                        await wait_for_loader(filtros_tab, timeout=20000)
                        pr("Loader posterior a Aceptar Emisi√≥n completado.", "INFO")
                    except:
                        pr("No se detect√≥ loader tras Aceptar Emisi√≥n (posible navegaci√≥n r√°pida).", "WARN")

                    return ok

                # ============================================================
                # REINTENTOS
                # ============================================================

                for intento in range(1, max_intentos_aceptar_emision + 1):
                    pr(f"Intento #{intento} click en {BTN_DESC}...", "INFO")
                    fired = await click_aceptar_emision_once()

                    # Verificar si el bot√≥n desapareci√≥ ‚Üí click exitoso
                    try:
                        visible = await filtros_tab.is_visible("xpath=//input[contains(@id,'btnAceptarEmision')]")
                    except:
                        visible = False

                    if not visible:
                        pr("Aceptar Emisi√≥n parece haberse ejecutado correctamente.", "OK")
                        break
                    else:
                        pr("Bot√≥n sigue visible: reintentando...", "WARN")
                        await asyncio.sleep(1)

                else:
                    pr("[ERROR] No se pudo disparar Aceptar Emisi√≥n despu√©s de m√∫ltiples intentos.", "ERROR")

                # FIN
                success = True
                url_final = filtros_tab.url

                if CONFIG.get("keep_open", True):
                    try:
                        print(
                            "\n---\nScript finalizado. El navegador y las pesta√±as quedan ABIERTOS.\n"
                            "Presiona ENTER para terminar solo el PROCESO (el navegador NO se cierra autom√°ticamente)‚Ä¶",
                            flush=True,
                        )
                        await asyncio.get_event_loop().run_in_executor(None, input)
                    except Exception:
                        print("Entorno sin stdin. Manteniendo proceso vivo‚Ä¶ (Ctrl+C para terminar)", flush=True)
                        await asyncio.sleep(24 * 3600)

    except Exception as e:
        err = str(e)
        pr(f"Error general: {err}", "ERROR")

    pr("Resumen JSON:")
    print(json.dumps({"success": success, "urlFinal": url_final, "error": err}, ensure_ascii=False), flush=True)


if __name__ == "__main__":
    asyncio.run(main())
